<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Awal√© 3D Challenge Pro</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { 
      width: 100%; 
      height: 100%; 
      font-family: 'Papyrus', 'Brush Script MT', cursive; 
      background: radial-gradient(circle at center, #3a2a1a 0%, #2a1a10 50%, #1a0f08 100%);
      overflow: hidden;
      touch-action: none;
    }
    
    #canvas-container {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    
    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    #landing, #game-ui {
      position: absolute;
      background: linear-gradient(145deg, rgba(245, 230, 211, 0.98) 0%, rgba(232, 213, 183, 0.98) 100%);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9), inset 0 2px 5px rgba(255, 255, 255, 0.4);
      border: 5px solid #8b5e3c;
      pointer-events: all;
      backdrop-filter: blur(12px);
    }
    
    #landing {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 380px;
    }
    
    #game-ui {
      top: 0;
      left: 0;
      right: 0;
      transform: none;
      width: 100%;
      max-width: 100%;
      text-align: center;
      padding: 10px 20px;
      border-radius: 0 0 15px 15px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 15px;
    }
    
    h1 { 
      text-align: center; 
      margin-bottom: 25px; 
      color: #3d2817;
      font-size: 3em;
      text-shadow: 3px 3px 6px rgba(0,0,0,0.4), 0 0 20px rgba(139, 94, 60, 0.5);
      letter-spacing: 10px;
      font-weight: bold;
    }
    
    .input-group { margin-bottom: 15px; }
    
    input[type="text"], select, input[type="range"] { 
      width: 100%; 
      padding: 10px; 
      margin-top: 6px;
      border: 3px solid #8b5e3c;
      border-radius: 8px;
      background: #fff;
      font-family: 'Segoe UI', sans-serif;
      font-size: 14px;
    }
    
    label { 
      display: block; 
      font-size: 15px; 
      margin-top: 10px;
      color: #5a3e1b;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
    }
    
    button { 
      width: 100%; 
      padding: 14px; 
      margin-top: 15px; 
      font-size: 18px; 
      background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
      color: #fff; 
      border: none; 
      border-radius: 10px; 
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 6px 20px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255, 255, 255, 0.3);
      transition: transform 0.2s, box-shadow 0.2s;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    }
    
    button:hover { 
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255, 255, 255, 0.4);
    }
    
    button:active { transform: scale(0.98); }
    
    #info { 
      font-size: 18px; 
      margin: 0;
      color: #3d2817;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
      flex: 1;
      min-width: 150px;
    }
    
    #timer { 
      font-size: 16px; 
      color: #e74c3c; 
      margin: 0;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
      min-width: 100px;
    }
    
    #scores { 
      display: flex; 
      justify-content: center;
      gap: 30px;
      margin: 0;
      font-size: 16px;
      color: #3d2817;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
      flex: 1;
      min-width: 200px;
    }
    
    #restartBtn { 
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      padding: 8px 20px;
      margin: 0;
      width: auto;
      min-width: 120px;
    }
    
    .btn-chambre-reception {
      display: inline-block;
      width: 100%;
      padding: 14px;
      margin-top: 15px;
      font-size: 16px;
      font-weight: 700;
      text-align: center;
      text-decoration: none;
      color: white;
      border-radius: 10px;
      transition: all 0.3s ease;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      background: linear-gradient(45deg, #FF6B6B, #F06595, #6C5CE7, #48A9A6);
      background-size: 400% 400%;
      animation: gradient-animation 10s ease infinite;
    }
    
    .btn-chambre-reception:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    }
    
    @keyframes gradient-animation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .hidden { display: none !important; }
    
    @media (max-width: 600px) {
      h1 { font-size: 2.2em; letter-spacing: 6px; }
      #landing { padding: 20px; }
      #game-ui { padding: 15px; min-width: 280px; }
      button { padding: 12px; font-size: 16px; }
    }
    
    .online-indicator {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #00ff00, #00cc00);
      box-shadow: 
        0 0 20px rgba(0, 255, 0, 0.8),
        0 0 40px rgba(0, 255, 0, 0.5),
        inset 0 2px 10px rgba(255, 255, 255, 0.5);
      pointer-events: none;
      z-index: 100;
      animation: onlinePulse 2s ease-in-out infinite;
      border: 4px solid rgba(255, 255, 255, 0.9);
      transition: all 0.5s ease;
    }
    
    .online-indicator.player1 {
      bottom: 48%;
      left: 2%;
    }
    
    .online-indicator.player2 {
      top: 48%;
      left: 2%;
    }
    
    @keyframes onlinePulse {
      0%, 100% { 
        transform: scale(1);
        box-shadow: 
          0 0 20px rgba(0, 255, 0, 0.8),
          0 0 40px rgba(0, 255, 0, 0.5),
          inset 0 2px 10px rgba(255, 255, 255, 0.5);
      }
      50% { 
        transform: scale(1.15);
        box-shadow: 
          0 0 30px rgba(0, 255, 0, 1),
          0 0 60px rgba(0, 255, 0, 0.7),
          inset 0 2px 10px rgba(255, 255, 255, 0.7);
      }
    }
    
    .seed-count-tooltip {
      position: absolute;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(30, 20, 10, 0.95));
      color: #FFD700;
      padding: 15px 25px;
      border-radius: 12px;
      font-size: 32px;
      font-weight: bold;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 6px 20px rgba(0,0,0,0.7);
      border: 3px solid #FFD700;
      animation: tooltipAppear 0.3s ease;
    }
    
    @keyframes tooltipAppear {
      from { opacity: 0; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1); }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="ui-overlay">
    <div id="landing">
      <h1>AWAL√â</h1>
      <div class="input-group">
        <label>Nom Joueur 1</label>
        <input type="text" id="player1" placeholder="Joueur 1">
      </div>
      <div class="input-group">
        <label>Nom Joueur 2</label>
        <input type="text" id="player2" placeholder="Joueur 2">
      </div>
      <div class="input-group">
        <label>Qui ramasse les graines restantes ?</label>
        <select id="collectRule">
          <option value="current">Joueur actif</option>
          <option value="opponent">Adversaire</option>
        </select>
      </div>
      <div class="input-group">
        <label><input type="checkbox" id="enableTimer"> Activer compte √† rebours</label>
      </div>
      <div class="input-group">
        <label>Dur√©e (3‚Äì10s) : <span id="delayValue">5</span>s</label>
        <input type="range" id="delayRange" min="3" max="10" value="5">
      </div>
      <button id="startBtn">Commencer la partie</button>
      <a href="chambre.html" class="btn-chambre-reception">Acc√©der √† la chambre de r√©ception</a>
    </div>

    <div id="game-ui" class="hidden">
      <div id="info"></div>
      <div id="scores"><span id="p1Score"></span><span id="p2Score"></span></div>
      <div id="timer"></div>
      <button id="restartBtn">Recommencer</button>
    </div>
    
    <div id="onlineIndicator" class="online-indicator hidden"></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  
  <script>
    let scene, camera, renderer, raycaster, mouse;
    let boardGroup, holeObjects = [], seedObjects = [];
    let board, currentPlayer, scores, pNames, collectRule;
    let timerEnabled, timerDuration, timerId;
    let animating = false;
    let longPressTimer = null;
    
    const landing = document.getElementById('landing');
    const gameUI = document.getElementById('game-ui');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const info = document.getElementById('info');
    const timerEl = document.getElementById('timer');
    const p1ScoreEl = document.getElementById('p1Score');
    const p2ScoreEl = document.getElementById('p2Score');
    const delayRange = document.getElementById('delayRange');
    const delayValue = document.getElementById('delayValue');
    const collectRuleSel = document.getElementById('collectRule');
    const onlineIndicator = document.getElementById('onlineIndicator');
    
    const parcours = [[1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0]];

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(freq, duration, type = 'sine', volume = 0.3) {
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.connect(gain);
      gain.connect(audioContext.destination);
      osc.frequency.value = freq;
      osc.type = type;
      gain.gain.setValueAtTime(volume, audioContext.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      osc.start();
      osc.stop(audioContext.currentTime + duration);
    }
    
    function playClickSound() { playSound(900, 0.08, 'sine', 0.25); }
    function playDropSound() { playSound(450, 0.12, 'triangle', 0.2); }
    function playCaptureSound() {
      playSound(650, 0.18, 'square', 0.25);
      setTimeout(() => playSound(750, 0.15, 'square', 0.2), 40);
    }
    function playWinSound() {
      playSound(523, 0.2, 'sine', 0.3);
      setTimeout(() => playSound(659, 0.2, 'sine', 0.3), 120);
      setTimeout(() => playSound(784, 0.35, 'sine', 0.35), 240);
    }

    delayRange.oninput = () => delayValue.textContent = delayRange.value;

    startBtn.onclick = () => {
      playClickSound();
      pNames = [document.getElementById('player1').value || 'Joueur 1', document.getElementById('player2').value || 'Joueur 2'];
      collectRule = collectRuleSel.value;
      timerEnabled = document.getElementById('enableTimer').checked;
      timerDuration = parseInt(delayRange.value);
      landing.classList.add('hidden');
      gameUI.classList.remove('hidden');
      initGame();
    };

    restartBtn.onclick = () => {
      playClickSound();
      initGame();
    };

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0503);
      
      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(42, aspect, 0.1, 1000);
      
      if (aspect < 1.2) {
        camera.position.set(0, 20, 20);
        camera.fov = 50;
      } else {
        camera.position.set(0, 16, 18);
        camera.fov = 42;
      }
      camera.updateProjectionMatrix();
      camera.lookAt(0, 0, 0);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.physicallyCorrectLights = true;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.4;
      document.getElementById('canvas-container').appendChild(renderer.domElement);
      
      const ambientLight = new THREE.AmbientLight(0xfff8f0, 3.0);
      scene.add(ambientLight);
      
      const mainLight = new THREE.DirectionalLight(0xfff5e6, 4.0);
      mainLight.position.set(15, 35, 18);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 2048;
      mainLight.shadow.mapSize.height = 2048;
      mainLight.shadow.camera.left = -40;
      mainLight.shadow.camera.right = 40;
      mainLight.shadow.camera.top = 40;
      mainLight.shadow.camera.bottom = -40;
      mainLight.shadow.bias = -0.0001;
      scene.add(mainLight);
      
      const fillLight1 = new THREE.PointLight(0xffffff, 3.0, 60);
      fillLight1.position.set(-12, 10, -6);
      scene.add(fillLight1);
      
      const fillLight2 = new THREE.PointLight(0xffffff, 3.0, 60);
      fillLight2.position.set(12, 10, 6);
      scene.add(fillLight2);
      
      const spotLight = new THREE.SpotLight(0xffffff, 2.5, 60, Math.PI / 5, 0.2, 1);
      spotLight.position.set(0, 25, 0);
      scene.add(spotLight);
      
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      window.addEventListener('resize', onWindowResize);
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mouseup', onMouseUp);
      renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
      renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
      
      createBoard();
      animate3D();
    }

    function createBoard() {
      boardGroup = new THREE.Group();
      
      const boardWidth = 25;
      const boardDepth = 11;
      const boardHeight = 2.5;
      
      // Table en dessous du plateau
      const tableGeometry = new THREE.BoxGeometry(35, 1.5, 20);
      const tableMaterial = new THREE.MeshStandardMaterial({
        color: 0x3d2817,
        roughness: 0.5,
        metalness: 0.1
      });
      const table = new THREE.Mesh(tableGeometry, tableMaterial);
      table.position.y = -boardHeight - 2;
      table.receiveShadow = true;
      scene.add(table);
      
      // Pieds de table
      const legGeometry = new THREE.CylinderGeometry(0.5, 0.6, 8, 16);
      const legMaterial = new THREE.MeshStandardMaterial({
        color: 0x2d1810,
        roughness: 0.6,
        metalness: 0.1
      });
      
      const legPositions = [
        [-14, -boardHeight - 6, -8],
        [14, -boardHeight - 6, -8],
        [-14, -boardHeight - 6, 8],
        [14, -boardHeight - 6, 8]
      ];
      
      legPositions.forEach(pos => {
        const leg = new THREE.Mesh(legGeometry, legMaterial);
        leg.position.set(...pos);
        leg.castShadow = true;
        scene.add(leg);
      });
      
      // Base du plateau
      const baseGeometry = new THREE.BoxGeometry(boardWidth, 1.0, boardDepth);
      const baseMaterial = new THREE.MeshStandardMaterial({
        color: 0x6b4423,
        roughness: 0.5,
        metalness: 0.15
      });
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = -boardHeight / 2 - 0.5;
      base.receiveShadow = true;
      base.castShadow = true;
      boardGroup.add(base);
      
      // Surface int√©rieure claire
      const innerGeometry = new THREE.BoxGeometry(boardWidth - 2.4, 0.8, boardDepth - 2.4);
      const innerMaterial = new THREE.MeshStandardMaterial({
        color: 0xE8D5B5,
        roughness: 0.3,
        metalness: 0.2,
        emissive: 0xE8D5B5,
        emissiveIntensity: 0.3
      });
      const inner = new THREE.Mesh(innerGeometry, innerMaterial);
      inner.position.y = -boardHeight / 2 + 0.8;
      inner.receiveShadow = true;
      boardGroup.add(inner);
      
      // Bordures
      const borderMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a3420,
        roughness: 0.55,
        metalness: 0.2
      });
      
      const borderThickness = 1.2;
      const borderHeight = 2.2;
      
      // Bordure haute
      const topBorder = new THREE.Mesh(
        new THREE.BoxGeometry(boardWidth, borderHeight, borderThickness),
        borderMaterial
      );
      topBorder.position.set(0, -boardHeight / 2 + borderHeight / 2, -boardDepth / 2 + borderThickness / 2);
      topBorder.castShadow = true;
      boardGroup.add(topBorder);
      
      // Bordure basse
      const bottomBorder = new THREE.Mesh(
        new THREE.BoxGeometry(boardWidth, borderHeight, borderThickness),
        borderMaterial
      );
      bottomBorder.position.set(0, -boardHeight / 2 + borderHeight / 2, boardDepth / 2 - borderThickness / 2);
      bottomBorder.castShadow = true;
      boardGroup.add(bottomBorder);
      
      // Bordure gauche
      const leftBorder = new THREE.Mesh(
        new THREE.BoxGeometry(borderThickness, borderHeight, boardDepth),
        borderMaterial
      );
      leftBorder.position.set(-boardWidth / 2 + borderThickness / 2, -boardHeight / 2 + borderHeight / 2, 0);
      leftBorder.castShadow = true;
      boardGroup.add(leftBorder);
      
      // Bordure droite
      const rightBorder = new THREE.Mesh(
        new THREE.BoxGeometry(borderThickness, borderHeight, boardDepth),
        borderMaterial
      );
      rightBorder.position.set(boardWidth / 2 - borderThickness / 2, -boardHeight / 2 + borderHeight / 2, 0);
      rightBorder.castShadow = true;
      boardGroup.add(rightBorder);
      
      // Charni√®res
      createHinge(-10, 0);
      createHinge(10, 0);
      
      // Trous ultra-profonds
      holeObjects = [];
      const holeRadius = 1.4;
      const holeDepth = 2.5;
      const spacingX = 3.6;
      const spacingZ = 4.5;
      
      for (let r = 0; r < 2; r++) {
        for (let c = 0; c < 6; c++) {
          const x = -9 + c * spacingX;
          const z = r === 0 ? -spacingZ / 2 : spacingZ / 2;
          
          const holeGroup = createHole(x, z, holeRadius, holeDepth, r, c);
          boardGroup.add(holeGroup);
          holeObjects.push(holeGroup);
        }
      }
      
      scene.add(boardGroup);
    }

    function createHinge(x, z) {
      const metalMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        metalness: 1.0,
        roughness: 0.08
      });
      
      const hinge = new THREE.Mesh(
        new THREE.BoxGeometry(0.9, 0.4, 1.6),
        metalMaterial
      );
      hinge.position.set(x, 0.8, z);
      hinge.castShadow = true;
      boardGroup.add(hinge);
      
      const axis = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15, 0.15, 1.7, 24),
        metalMaterial
      );
      axis.position.set(x, 1.0, z);
      axis.rotation.x = Math.PI / 2;
      boardGroup.add(axis);
    }

    function createHole(x, z, radius, depth, row, col) {
      const holeGroup = new THREE.Group();
      holeGroup.position.set(x, 0, z);
      holeGroup.userData = { row, col, isHole: true };
      
      // Parois du trou ultra-sombres
      const holeGeometry = new THREE.CylinderGeometry(radius, radius * 0.85, depth, 64);
      const holeMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a0f08,
        roughness: 0.9,
        metalness: 0.0
      });
      const hole = new THREE.Mesh(holeGeometry, holeMaterial);
      hole.position.y = -depth / 2 + 0.8;
      hole.receiveShadow = true;
      holeGroup.add(hole);
      
      // Fond noir profond
      const bottomGeometry = new THREE.CircleGeometry(radius * 0.85, 64);
      const bottomMaterial = new THREE.MeshStandardMaterial({
        color: 0x0a0503,
        roughness: 1.0
      });
      const bottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
      bottom.rotation.x = -Math.PI / 2;
      bottom.position.y = -depth + 0.8;
      bottom.receiveShadow = true;
      holeGroup.add(bottom);
      
      // Bordure brillante
      const ringGeometry = new THREE.TorusGeometry(radius, 0.25, 40, 64);
      const ringMaterial = new THREE.MeshStandardMaterial({
        color: 0x8B6914,
        roughness: 0.15,
        metalness: 0.5,
        clearcoat: 1.0,
        clearcoatRoughness: 0.05
      });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.8;
      ring.castShadow = true;
      holeGroup.add(ring);
      
      return holeGroup;
    }

    // G√©n√©rateur de graines uniques
    const seedPatterns = [
      { colors: [0xFFD700, 0xFFE55C], scale: [1, 0.9, 1.1], spots: 8 },
      { colors: [0xFFA500, 0xFFBF3F], scale: [1.05, 0.88, 1.08], spots: 6 },
      { colors: [0xFF8C00, 0xFFA433], scale: [0.98, 0.92, 1.12], spots: 10 },
      { colors: [0xF4A460, 0xF7BC7D], scale: [1.02, 0.9, 1.1], spots: 7 },
      { colors: [0xDAA520, 0xE6B84D], scale: [1, 0.87, 1.15], spots: 9 },
      { colors: [0xFFB347, 0xFFC46B], scale: [1.03, 0.91, 1.09], spots: 5 },
      { colors: [0xFF7F50, 0xFF9A7A], scale: [0.99, 0.89, 1.13], spots: 8 },
      { colors: [0xFFA07A, 0xFFB599], scale: [1.01, 0.93, 1.07], spots: 6 }
    ];

    function createSeed(x, y, z) {
      const seedGroup = new THREE.Group();
      const pattern = seedPatterns[Math.floor(Math.random() * seedPatterns.length)];
      
      const seedGeometry = new THREE.SphereGeometry(0.40, 48, 48);
      seedGeometry.scale(...pattern.scale);
      
      const seedMaterial = new THREE.MeshStandardMaterial({
        color: pattern.colors[0],
        roughness: 0.15,
        metalness: 0.5,
        emissive: pattern.colors[1],
        emissiveIntensity: 0.7,
        clearcoat: 0.9,
        clearcoatRoughness: 0.1
      });
      
      const seed = new THREE.Mesh(seedGeometry, seedMaterial);
      seed.castShadow = true;
      seed.receiveShadow = true;
      
      seed.rotation.x = Math.random() * Math.PI * 2;
      seed.rotation.y = Math.random() * Math.PI * 2;
      seed.rotation.z = Math.random() * Math.PI * 2;
      
      seedGroup.add(seed);
      
      // Lumi√®re personnalis√©e pour chaque graine
      const glowLight = new THREE.PointLight(pattern.colors[1], 1.2, 2.5);
      seedGroup.add(glowLight);
      
      seedGroup.position.set(x, y, z);
      seedGroup.userData = { pattern: pattern };
      
      return seedGroup;
    }

    function getHolePosition(row, col) {
      const x = -9 + col * 3.6;
      const z = row === 0 ? -2.25 : 2.25;
      return { x, z };
    }

    function positionSeedsInHole(row, col, count) {
      const seeds = [];
      const pos = getHolePosition(row, col);
      const baseY = 1.8;
      
      if (count === 0) return seeds;
      
      for (let i = 0; i < count; i++) {
        let sx, sz, sy;
        
        if (count === 1) {
          sx = pos.x;
          sz = pos.z;
          sy = baseY;
        } else if (count <= 4) {
          const angle = (i / count) * Math.PI * 2 + Math.PI / 4;
          const radius = 0.52;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = baseY;
        } else if (count <= 8) {
          const layer = Math.floor(i / 4);
          const posInLayer = i % 4;
          const angle = (posInLayer / 4) * Math.PI * 2 + Math.PI / 4;
          const radius = layer === 0 ? 0.58 : 0.32;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = baseY + layer * 0.5;
        } else {
          const layer = Math.floor(i / 6);
          const posInLayer = i % 6;
          const angle = (posInLayer / 6) * Math.PI * 2;
          const radius = 0.42 + (layer % 2) * 0.32;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = baseY + layer * 0.48;
        }
        
        seeds.push({ x: sx, y: sy, z: sz });
      }
      
      return seeds;
    }

    function updateSeeds() {
      seedObjects.forEach(seed => boardGroup.remove(seed));
      seedObjects = [];
      
      for (let r = 0; r < 2; r++) {
        for (let c = 0; c < 6; c++) {
          const count = board[r][c];
          const positions = positionSeedsInHole(r, c, count);
          
          positions.forEach(pos => {
            const seed = createSeed(pos.x, pos.y, pos.z);
            boardGroup.add(seed);
            seedObjects.push(seed);
          });
        }
      }
    }

    function animate3D() {
      requestAnimationFrame(animate3D);
      
      seedObjects.forEach((seed, i) => {
        const mainSeed = seed.children[0];
        mainSeed.rotation.y += 0.005 * Math.sin(i * 0.3);
        seed.position.y += Math.sin(Date.now() * 0.0015 + i * 0.7) * 0.0015;
      });
      
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;
      camera.aspect = aspect;
      
      if (aspect < 1.2) {
        camera.fov = 50;
        camera.position.set(0, 20, 20);
      } else if (aspect < 1.5) {
        camera.fov = 46;
        camera.position.set(0, 18, 19);
      } else {
        camera.fov = 42;
        camera.position.set(0, 16, 18);
      }
      
      camera.updateProjectionMatrix();
      camera.lookAt(0, 0, 0);
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    let touchStartPos = null;

    function onTouchStart(event) {
      event.preventDefault();
      if (animating) return;
      
      const touch = event.touches[0];
      touchStartPos = { x: touch.clientX, y: touch.clientY };
      
      mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      if (intersects.length > 0) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          longPressTimer = setTimeout(() => {
            showSeedCount(hole, touch.clientX, touch.clientY);
          }, 500);
        }
      }
    }

    function onTouchEnd(event) {
      event.preventDefault();
      
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      
      const tooltip = document.querySelector('.seed-count-tooltip');
      if (tooltip) tooltip.remove();
      
      if (animating || !touchStartPos) return;
      
      const touch = event.changedTouches[0];
      const dx = touch.clientX - touchStartPos.x;
      const dy = touch.clientY - touchStartPos.y;
      
      if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(holeObjects, true);
        
        if (intersects.length > 0) {
          let hole = intersects[0].object;
          while (hole.parent && !hole.userData.isHole) {
            hole = hole.parent;
          }
          
          if (hole.userData.isHole) {
            const r = hole.userData.row;
            const c = hole.userData.col;
            
            if ((currentPlayer === 1 && r === 1) || (currentPlayer === 2 && r === 0)) {
              if (board[r][c] > 0) {
                playClickSound();
                play(r, c);
              }
            }
          }
        }
      }
      
      touchStartPos = null;
    }
    
    function showSeedCount(hole, x, y) {
      const r = hole.userData.row;
      const c = hole.userData.col;
      const count = board[r][c];
      
      const tooltip = document.createElement('div');
      tooltip.className = 'seed-count-tooltip';
      tooltip.textContent = `üå∞ ${count}`;
      tooltip.style.left = x + 'px';
      tooltip.style.top = (y - 70) + 'px';
      
      document.body.appendChild(tooltip);
      
      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      holeObjects.forEach(hole => {
        hole.children.forEach(child => {
          if (child.material && child.material.emissive) {
            child.material.emissive.setHex(0x000000);
            child.material.emissiveIntensity = 0;
          }
        });
      });
      
      if (intersects.length > 0 && !animating) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          const r = hole.userData.row;
          const c = hole.userData.col;
          
          if ((currentPlayer === 1 && r === 1) || (currentPlayer === 2 && r === 0)) {
            if (board[r][c] > 0) {
              hole.children[2].material.emissive.setHex(0xff6600);
              hole.children[2].material.emissiveIntensity = 0.8;
              renderer.domElement.style.cursor = 'pointer';
              return;
            }
          }
        }
      }
      renderer.domElement.style.cursor = 'default';
    }
    
    function onMouseDown(event) {
      if (animating) return;
      
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      if (intersects.length > 0) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          longPressTimer = setTimeout(() => {
            showSeedCount(hole, event.clientX, event.clientY);
          }, 500);
        }
      }
    }
    
    function onMouseUp() {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      
      const tooltip = document.querySelector('.seed-count-tooltip');
      if (tooltip) tooltip.remove();
    }

    function onMouseClick(event) {
      if (animating) return;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      if (intersects.length > 0) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          const r = hole.userData.row;
          const c = hole.userData.col;
          
          if ((currentPlayer === 1 && r === 1) || (currentPlayer === 2 && r === 0)) {
            if (board[r][c] > 0) {
              playClickSound();
              play(r, c);
            }
          }
        }
      }
    }

    function initGame() {
      board = Array.from({ length: 2 }, () => Array(6).fill(4));
      scores = [0, 0];
      currentPlayer = 1;
      animating = false;
      updateDisplay();
      updateSeeds();
    }

    function startTimer() {
      clearTimer();
      if (!timerEnabled) return;
      let rem = timerDuration;
      timerEl.textContent = `Temps: ${rem}s`;
      timerId = setInterval(() => {
        rem--;
        timerEl.textContent = `Temps: ${rem}s`;
        if (rem < 0) {
          clearTimer();
          const loser = currentPlayer;
          const winner = loser === 1 ? 2 : 1;
          const msg = `Temps √©coul√© ! ${pNames[loser - 1]} n'a pas jou√© √† temps.\n${pNames[winner - 1]} remporte la partie.`;
          handleWinner(winner, msg, false);
        }
      }, 1000);
    }

    function clearTimer() {
      clearInterval(timerId);
      timerEl.textContent = '';
    }

    function updateDisplay() {
      p1ScoreEl.textContent = `${pNames[0]}: ${scores[0]}`;
      p2ScoreEl.textContent = `${pNames[1]}: ${scores[1]}`;
      info.textContent = `Tour de ${pNames[currentPlayer - 1]}`;
      
      onlineIndicator.classList.remove('hidden', 'player1', 'player2');
      onlineIndicator.classList.add(currentPlayer === 1 ? 'player1' : 'player2');
      
      startTimer();
    }

    async function animateSeedMovement(seed, startPos, endPos) {
      const duration = 650;
      const startTime = Date.now();
      
      return new Promise(resolve => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const t = Math.min(elapsed / duration, 1);
          
          const easeT = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
          
          const height = 4.5;
          seed.position.x = startPos.x + (endPos.x - startPos.x) * easeT;
          seed.position.z = startPos.z + (endPos.z - startPos.z) * easeT;
          seed.position.y = startPos.y + Math.sin(easeT * Math.PI) * height;
          
          seed.children[0].rotation.x += 0.25;
          seed.children[0].rotation.y += 0.22;
          seed.children[0].rotation.z += 0.18;
          
          if (t < 1) {
            requestAnimationFrame(animate);
          } else {
            seed.position.set(endPos.x, endPos.y, endPos.z);
            resolve();
          }
        }
        animate();
      });
    }

    async function play(r0, c0) {
      if (animating) return;
      animating = true;
      clearTimer();
      
      let seedCount = board[r0][c0];
      if (!seedCount) {
        animating = false;
        return;
      }
      
      board[r0][c0] = 0;
      let idx = parcours.findIndex(p => p[0] === r0 && p[1] === c0);
      
      const startPositions = positionSeedsInHole(r0, c0, seedCount);
      const movingSeeds = [];
      
      for (let i = 0; i < seedCount; i++) {
        const pos = startPositions[i];
        const seed = createSeed(pos.x, pos.y, pos.z);
        boardGroup.add(seed);
        movingSeeds.push(seed);
      }
      
      updateSeeds();
      await new Promise(resolve => setTimeout(resolve, 150));
      
      for (let i = 0; i < movingSeeds.length; i++) {
        const seed = movingSeeds[i];
        idx = (idx + 1) % 12;
        let [r, c] = parcours[idx];
        
        if (r === r0 && c === c0) {
          idx = (idx + 1) % 12;
          [r, c] = parcours[idx];
        }
        
        board[r][c]++;
        
        const startPos = getHolePosition(r0, c0);
        const endPositions = positionSeedsInHole(r, c, board[r][c]);
        const endPos = endPositions[endPositions.length - 1];
        
        playDropSound();
        await animateSeedMovement(seed, startPos, endPos);
        
        boardGroup.remove(seed);
        updateSeeds();
        
        await new Promise(resolve => setTimeout(resolve, 140));
      }
      
      let cap = 0, count = 0, j = idx;
      while (count < 5) {
        let [r, c] = parcours[j];
        if ((currentPlayer === 1 && r === 0) || (currentPlayer === 2 && r === 1)) {
          let v = board[r][c];
          if (v === 2 || v === 3) {
            cap += v;
            playCaptureSound();
            
            const capturePositions = positionSeedsInHole(r, c, v);
            const capturingSeeds = [];
            
            for (let pos of capturePositions) {
              const seed = createSeed(pos.x, pos.y, pos.z);
              boardGroup.add(seed);
              capturingSeeds.push(seed);
            }
            
            board[r][c] = 0;
            updateSeeds();
            
            const captureStart = Date.now();
            const captureDuration = 480;
            
            await new Promise(resolve => {
              function animateCapture() {
                const elapsed = Date.now() - captureStart;
                const progress = Math.min(elapsed / captureDuration, 1);
                
                capturingSeeds.forEach(seed => {
                  const scale = 1 - progress;
                  seed.scale.set(scale, scale, scale);
                  seed.position.y += 0.18;
                  seed.children[0].rotation.y += 0.45;
                  seed.children[0].rotation.x += 0.35;
                });
                
                if (progress < 1) {
                  requestAnimationFrame(animateCapture);
                } else {
                  capturingSeeds.forEach(seed => boardGroup.remove(seed));
                  resolve();
                }
              }
              animateCapture();
            });
            
            await new Promise(resolve => setTimeout(resolve, 180));
            
            count++;
            j = (j - 1 + 12) % 12;
            continue;
          }
        }
        break;
      }
      
      scores[currentPlayer - 1] += cap;
      
      const next = currentPlayer === 1 ? 2 : 1;
      const flat = board.flat();
      
      if (flat.every(v => v === 0) || board[next === 1 ? 1 : 0].every(v => v === 0)) {
        const remaining = flat.reduce((a, b) => a + b, 0);
        board = Array.from({ length: 2 }, () => Array(6).fill(0));
        let collector = collectRule === 'current' ? currentPlayer : (currentPlayer === 1 ? 2 : 1);
        const before = scores[collector - 1];
        scores[collector - 1] += remaining;
        const total = scores[collector - 1];
        
        let message = `${pNames[collector - 1]} ramasse ${remaining} graines.\nScore: ${before}+${remaining}=${total}`;
        if (total > 24) message += `\nüéâ ${pNames[collector - 1]} gagne !`;
        else if (total === 24) message += `\n√âGALIT√â 24-24, nouvelle partie !`;
        else message += `\nMoins de 25: ${pNames[(collector === currentPlayer ? next : currentPlayer) - 1]} gagne !`;
        
        handleWinner(collector, message, total === 24);
        animating = false;
        return;
      }
      
      if (scores[currentPlayer - 1] >= 25) {
        handleWinner(currentPlayer, `üéâ ${pNames[currentPlayer - 1]} atteint 25 graines !`, false);
        animating = false;
        return;
      }
      
      currentPlayer = next;
      updateDisplay();
      animating = false;
    }

    function handleWinner(idx, message, isTie = false) {
      clearTimer();
      playWinSound();
      confetti({ 
        particleCount: 700, 
        spread: 170, 
        origin: { y: 0.6 },
        colors: ['#FFD700', '#FFA500', '#FF6347', '#FF69B4', '#00CED1', '#7FFF00', '#FF1493']
      });
      
      let s1 = scores[0], s2 = scores[1];
      let final = message + `\nScore final: ${s1}-${s2}`;
      
      if (isTie) {
        final += `\nRecommence dans 2s.`;
        timerDuration = Math.max(3, timerDuration - 1);
        info.textContent = final;
        setTimeout(initGame, 2000);
      } else {
        info.textContent = final;
      }
    }

    initThree();
  </script>
</body>
</html>
