<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Three.js — Demo locale (module)</title>
  <style>
    html,body{height:100%;margin:0;background:#05060a;color:#ddd;font-family:Arial,Helvetica,sans-serif}
    #ui{position:fixed;left:12px;top:12px;z-index:20;background:rgba(0,0,0,0.45);padding:8px;border-radius:8px}
    #log{position:fixed;right:12px;top:12px;z-index:20;background:rgba(0,0,0,0.45);padding:8px;border-radius:8px;font-family:monospace;font-size:13px;max-width:360px;max-height:50vh;overflow:auto}
    a{color:#7fd}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="ui">
    <div style="font-size:14px;font-weight:600">Demo Three.js — local (module)</div>
    <div style="font-size:12px;margin-top:6px">Contrôles : glisser/déplacer = orbite · molette = zoom · H = cacher UI</div>
    <div style="margin-top:6px"><a id="reset" href="#">Réinitialiser caméra</a></div>
  </div>

  <div id="log">Démarrage…</div>

  <!-- IMPORTANT: on n'utilise PAS de <script src="https://...three.min.js"> classique ici,
       on importe la version module locale (three.min.js = three.module.js sauvegardé localement) -->
  <script type="module">
  const logEl = document.getElementById('log');
  function log(msg, cls){ const d = document.createElement('div'); if(cls) d.className = cls; d.textContent = msg; logEl.appendChild(d); logEl.scrollTop = logEl.scrollHeight; console.log(msg); }

  // Importer Three.js depuis le fichier local (module)
  import * as THREE from './three.min.js';

  // Option: charger lil-gui si présent (module ESM). On tente et on continue sans si absent.
  let GUI = null;
  try {
    const mod = await import('./lil-gui.min.js');
    GUI = (mod && (mod.default || mod.GUI || mod));
    log('lil-gui chargé', 'ok');
  } catch(e) {
    log('lil-gui non trouvé (optionnel) — continuer sans GUI', 'err');
  }

  log('Three.js importé (module)', 'ok');

  // --- Scene de base ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x05060a);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.05, 2000);
  camera.position.set(0, 1.2, 4);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  // Controls : si OrbitControls n'est pas disponible localement, on crée un contrôle simple
  // (si tu veux OrbitControls en local, il faut aussi l'ajouter depuis /examples/jsm/controls/OrbitControls.js)
  // Ici on propose un contrôle basique via drag pour tourner la caméra autour de la cible.
  let isDown = false, startX=0, startY=0, yaw=0, pitch=0;
  const target = new THREE.Vector3(0, 0.6, 0);

  renderer.domElement.addEventListener('pointerdown', (e)=>{ isDown=true; startX=e.clientX; startY=e.clientY; renderer.domElement.setPointerCapture(e.pointerId); });
  window.addEventListener('pointerup', ()=>{ isDown=false; });
  window.addEventListener('pointermove', (e)=>{ if(!isDown) return; const dx=(e.clientX-startX)*0.005; const dy=(e.clientY-startY)*0.005; yaw += dx; pitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, pitch+dy)); startX=e.clientX; startY=e.clientY; });

  window.addEventListener('wheel', (e)=>{ camera.position.z += e.deltaY * 0.002; camera.position.z = Math.max(1.0, Math.min(30, camera.position.z)); });

  // Lights
  const dir = new THREE.DirectionalLight(0xffffff, 1.1);
  dir.position.set(3,6,2);
  dir.castShadow = true;
  scene.add(dir);
  scene.add(new THREE.AmbientLight(0x404040, 0.7));

  // Ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({ color:0x071226, roughness:0.9 }));
  ground.rotation.x = -Math.PI/2; ground.position.y = -0.75; ground.receiveShadow = true; scene.add(ground);

  // Objects: cube, sphere, torus
  const cube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({ color:0x00ff99 }));
  cube.position.x = -2; cube.castShadow=true; scene.add(cube);

  const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 32), new THREE.MeshStandardMaterial({ color:0xff3399 }));
  sphere.castShadow = true; scene.add(sphere);

  const torus = new THREE.Mesh(new THREE.TorusGeometry(0.7, 0.25, 16, 100), new THREE.MeshStandardMaterial({ color:0x3399ff }));
  torus.position.x = 2; torus.castShadow=true; scene.add(torus);

  // Simple particle points using BufferGeometry (lightweight)
  const particleCount = 400;
  const pos = new Float32Array(particleCount * 3);
  for(let i=0;i<particleCount;i++){
    const a = Math.random()*Math.PI*2; const r = 1.8 + Math.random()*3.0;
    pos[i*3+0] = Math.cos(a)*r;
    pos[i*3+1] = (Math.random()-0.5)*1.6;
    pos[i*3+2] = Math.sin(a)*r;
  }
  const pg = new THREE.BufferGeometry();
  pg.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  const pm = new THREE.PointsMaterial({ size:6, color:0xffffff, depthWrite:false, transparent:true, opacity:0.9 });
  const points = new THREE.Points(pg, pm);
  scene.add(points);

  // Camera reset link
  document.getElementById('reset').addEventListener('click', (e)=>{ e.preventDefault(); camera.position.set(0,1.2,4); yaw = pitch = 0; log('Caméra réinitialisée'); });

  // Optional GUI if present
  if(GUI){
    try{
      const gui = new GUI();
      gui.add({speed:1}, 'speed', 0.1, 3, 0.1).name('Vitesse (ex.)');
      log('GUI initialisée', 'ok');
    }catch(e){ console.warn(e); }
  }

  // Animation loop
  const clock = new THREE.Clock();
  function animate(){
    const dt = Math.min(clock.getDelta(), 0.05);
    // orbit camera around target using yaw/pitch
    const radius = camera.position.z;
    const x = Math.cos(yaw) * radius;
    const z = Math.sin(yaw) * radius;
    const y = Math.sin(pitch) * radius + 0.7;
    camera.position.set(x, y, z);
    camera.lookAt(target);

    // objects anim
    cube.rotation.x += 0.02; cube.rotation.y += 0.03;
    sphere.rotation.x += 0.015; sphere.position.y = 0.3 + Math.sin(Date.now()*0.002) * 0.6;
    torus.rotation.y += 0.02;

    points.rotation.y += 0.005;

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // Resize handling
  window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

  // Final checks
  log('Initialisation OK — animation lancée', 'ok');
  animate();

  // Toggle UI with H
  window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase() === 'h'){ const u = document.getElementById('ui'); u.style.display = u.style.display === 'none' ? 'block' : 'none'; } });

  </script>
</body>
</html>
