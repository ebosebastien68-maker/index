<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Awal√© 3D Challenge Pro</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { 
      width: 100%; 
      height: 100%; 
      font-family: 'Papyrus', 'Brush Script MT', cursive; 
      background: linear-gradient(135deg, #e8d5b7 0%, #d4c5a9 100%);
      overflow: hidden;
    }
    
    #canvas-container {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    
    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    #landing, #game-ui {
      position: absolute;
      background: rgba(245, 230, 195, 0.98);
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 10px 40px rgba(90, 62, 27, 0.6);
      border: 4px solid #8b5e3c;
      pointer-events: all;
    }
    
    #landing {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 350px;
    }
    
    #game-ui {
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: auto;
      min-width: 400px;
      text-align: center;
    }
    
    h1 { 
      text-align: center; 
      margin-bottom: 20px; 
      color: #3d2817;
      font-size: 2.8em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      letter-spacing: 8px;
      font-weight: bold;
    }
    
    .input-group { 
      margin-bottom: 15px; 
    }
    
    input[type="text"], select, input[type="range"] { 
      width: 100%; 
      padding: 8px; 
      margin-top: 6px;
      border: 2px solid #8b5e3c;
      border-radius: 5px;
      background: #fff;
      font-family: 'Segoe UI', sans-serif;
    }
    
    label { 
      display: block; 
      font-size: 14px; 
      margin-top: 10px;
      color: #5a3e1b;
      font-weight: bold;
    }
    
    button { 
      width: 100%; 
      padding: 12px; 
      margin-top: 15px; 
      font-size: 18px; 
      background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
      color: #fff; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      transition: transform 0.2s;
    }
    
    button:hover { 
      transform: scale(1.05);
    }
    
    #info { 
      font-size: 20px; 
      margin-bottom: 10px;
      color: #3d2817;
      font-weight: bold;
    }
    
    #timer { 
      font-size: 18px; 
      color: #e74c3c; 
      margin-bottom: 10px;
      font-weight: bold;
    }
    
    #scores { 
      display: flex; 
      justify-content: space-between; 
      margin-bottom: 10px; 
      font-size: 18px;
      color: #3d2817;
      font-weight: bold;
    }
    
    #restartBtn { 
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    }
    
    .btn-chambre-reception {
      display: inline-block;
      width: 100%;
      padding: 12px;
      margin-top: 15px;
      font-size: 16px;
      font-weight: 700;
      text-align: center;
      text-decoration: none;
      color: white;
      border-radius: 8px;
      transition: all 0.3s ease;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      background: linear-gradient(45deg, #FF6B6B, #F06595, #6C5CE7, #48A9A6);
      background-size: 400% 400%;
      animation: gradient-animation 10s ease infinite;
    }
    
    .btn-chambre-reception:hover {
      transform: scale(1.05);
    }
    
    @keyframes gradient-animation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="ui-overlay">
    <div id="landing">
      <h1>AWAL√â</h1>
      <div class="input-group">
        <label>Nom Joueur 1</label>
        <input type="text" id="player1" placeholder="Joueur 1">
      </div>
      <div class="input-group">
        <label>Nom Joueur 2</label>
        <input type="text" id="player2" placeholder="Joueur 2">
      </div>
      <div class="input-group">
        <label>Qui ramasse les graines restantes ?</label>
        <select id="collectRule">
          <option value="current">Joueur actif</option>
          <option value="opponent">Adversaire</option>
        </select>
      </div>
      <div class="input-group">
        <label><input type="checkbox" id="enableTimer"> Activer compte √† rebours</label>
      </div>
      <div class="input-group">
        <label>Dur√©e (3‚Äì10s) : <span id="delayValue">5</span>s</label>
        <input type="range" id="delayRange" min="3" max="10" value="5">
      </div>
      <button id="startBtn">Commencer la partie</button>
      <a href="chambre.html" class="btn-chambre-reception">Acc√©der √† la chambre de r√©ception</a>
    </div>

    <div id="game-ui" class="hidden">
      <div id="info"></div>
      <div id="timer"></div>
      <div id="scores"><span id="p1Score"></span><span id="p2Score"></span></div>
      <button id="restartBtn">Recommencer</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  
  <script>
    let scene, camera, renderer, raycaster, mouse;
    let boardGroup, holeObjects = [], seedObjects = [];
    let board, currentPlayer, scores, pNames, collectRule;
    let timerEnabled, timerDuration, timerId;
    let animating = false;
    
    const landing = document.getElementById('landing');
    const gameUI = document.getElementById('game-ui');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const info = document.getElementById('info');
    const timerEl = document.getElementById('timer');
    const p1ScoreEl = document.getElementById('p1Score');
    const p2ScoreEl = document.getElementById('p2Score');
    const delayRange = document.getElementById('delayRange');
    const delayValue = document.getElementById('delayValue');
    const collectRuleSel = document.getElementById('collectRule');
    
    const parcours = [[1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0]];

    // Sons
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(freq, duration, type = 'sine') {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = freq;
      oscillator.type = type;
      
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    }
    
    function playClickSound() { playSound(800, 0.1, 'sine'); }
    function playDropSound() { playSound(400, 0.15, 'triangle'); }
    function playCaptureSound() {
      playSound(600, 0.2, 'square');
      setTimeout(() => playSound(700, 0.15, 'square'), 50);
    }
    function playWinSound() {
      playSound(523, 0.2);
      setTimeout(() => playSound(659, 0.2), 100);
      setTimeout(() => playSound(784, 0.3), 200);
    }

    delayRange.oninput = () => delayValue.textContent = delayRange.value;

    startBtn.onclick = () => {
      playClickSound();
      pNames = [document.getElementById('player1').value || 'Joueur 1', document.getElementById('player2').value || 'Joueur 2'];
      collectRule = collectRuleSel.value;
      timerEnabled = document.getElementById('enableTimer').checked;
      timerDuration = parseInt(delayRange.value);
      landing.classList.add('hidden');
      gameUI.classList.remove('hidden');
      initGame();
    };

    restartBtn.onclick = () => {
      playClickSound();
      initGame();
    };

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xfaf5ed);
      
      camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 13, 14);
      camera.lookAt(0, 0, 0);
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.physicallyCorrectLights = true;
      document.getElementById('canvas-container').appendChild(renderer.domElement);
      
      // Lumi√®res optimis√©es pour voir les graines
      const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
      scene.add(ambientLight);
      
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
      mainLight.position.set(8, 20, 10);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 4096;
      mainLight.shadow.mapSize.height = 4096;
      mainLight.shadow.camera.left = -25;
      mainLight.shadow.camera.right = 25;
      mainLight.shadow.camera.top = 25;
      mainLight.shadow.camera.bottom = -25;
      mainLight.shadow.bias = -0.0005;
      scene.add(mainLight);
      
      // Lumi√®res pour √©clairer l'int√©rieur des trous
      const fillLight1 = new THREE.PointLight(0xffffff, 0.8, 30);
      fillLight1.position.set(-5, 3, -2);
      scene.add(fillLight1);
      
      const fillLight2 = new THREE.PointLight(0xffffff, 0.8, 30);
      fillLight2.position.set(5, 3, 2);
      scene.add(fillLight2);
      
      const topLight = new THREE.DirectionalLight(0xfff8f0, 0.7);
      topLight.position.set(0, 15, 0);
      scene.add(topLight);
      
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      window.addEventListener('resize', onWindowResize);
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      
      createBoard();
      animate3D();
    }

    function createWoodTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 2048;
      canvas.height = 2048;
      const ctx = canvas.getContext('2d');
      
      const gradient = ctx.createLinearGradient(0, 0, 2048, 2048);
      gradient.addColorStop(0, '#c9a876');
      gradient.addColorStop(0.3, '#b89968');
      gradient.addColorStop(0.6, '#a68958');
      gradient.addColorStop(1, '#8b7355');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 2048, 2048);
      
      // Veines
      for (let i = 0; i < 100; i++) {
        ctx.strokeStyle = `rgba(${60 + Math.random() * 30}, ${40 + Math.random() * 20}, ${25 + Math.random() * 15}, ${0.15 + Math.random() * 0.25})`;
        ctx.lineWidth = 1 + Math.random() * 3;
        ctx.beginPath();
        const startX = Math.random() * 2048;
        ctx.moveTo(startX, 0);
        
        for (let j = 0; j < 6; j++) {
          const cpX = startX + (Math.random() - 0.5) * 600;
          const cpY = j * 350 + (Math.random() - 0.5) * 150;
          const endX = startX + (Math.random() - 0.5) * 800;
          const endY = (j + 1) * 350;
          ctx.quadraticCurveTo(cpX, cpY, endX, endY);
        }
        ctx.stroke();
      }
      
      // N≈ìuds
      for (let i = 0; i < 30; i++) {
        const x = Math.random() * 2048;
        const y = Math.random() * 2048;
        const radius = 20 + Math.random() * 50;
        
        for (let ring = 4; ring > 0; ring--) {
          const grad = ctx.createRadialGradient(x, y, 0, x, y, radius * ring / 4);
          grad.addColorStop(0, `rgba(70, 45, 30, ${0.25 * ring / 4})`);
          grad.addColorStop(1, 'rgba(70, 45, 30, 0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(x, y, radius * ring / 4, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      const texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      return texture;
    }

    function createBoard() {
      boardGroup = new THREE.Group();
      
      const boardWidth = 19;
      const boardDepth = 9;
      const boardHeight = 1.5;
      const borderHeight = 1.2;
      const borderThickness = 1;
      
      const woodTexture = createWoodTexture();
      
      // Base du plateau
      const baseGeometry = new THREE.BoxGeometry(boardWidth, 0.5, boardDepth);
      const baseMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture,
        color: 0xa68958,
        roughness: 0.75,
        metalness: 0.05
      });
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = -boardHeight / 2 - 0.25;
      base.receiveShadow = true;
      base.castShadow = true;
      boardGroup.add(base);
      
      // Surface int√©rieure CLAIRE pour voir les graines
      const innerGeometry = new THREE.BoxGeometry(
        boardWidth - borderThickness * 2,
        0.4,
        boardDepth - borderThickness * 2
      );
      const innerMaterial = new THREE.MeshStandardMaterial({
        color: 0xd4c4a8, // Couleur tr√®s claire
        roughness: 0.6,
        metalness: 0.1
      });
      const inner = new THREE.Mesh(innerGeometry, innerMaterial);
      inner.position.y = -boardHeight / 2 + 0.4;
      inner.receiveShadow = true;
      boardGroup.add(inner);
      
      // Bordures
      const borderMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture,
        color: 0x8b7355,
        roughness: 0.8,
        metalness: 0.05
      });
      
      // Bordure haute
      const topBorder = new THREE.Mesh(
        new THREE.BoxGeometry(boardWidth, borderHeight, borderThickness),
        borderMaterial
      );
      topBorder.position.set(0, -boardHeight / 2 + borderHeight / 2, -boardDepth / 2 + borderThickness / 2);
      topBorder.castShadow = true;
      topBorder.receiveShadow = true;
      boardGroup.add(topBorder);
      
      // Bordure basse
      const bottomBorder = new THREE.Mesh(
        new THREE.BoxGeometry(boardWidth, borderHeight, borderThickness),
        borderMaterial
      );
      bottomBorder.position.set(0, -boardHeight / 2 + borderHeight / 2, boardDepth / 2 - borderThickness / 2);
      bottomBorder.castShadow = true;
      bottomBorder.receiveShadow = true;
      boardGroup.add(bottomBorder);
      
      // Bordure gauche
      const leftBorder = new THREE.Mesh(
        new THREE.BoxGeometry(borderThickness, borderHeight, boardDepth),
        borderMaterial
      );
      leftBorder.position.set(-boardWidth / 2 + borderThickness / 2, -boardHeight / 2 + borderHeight / 2, 0);
      leftBorder.castShadow = true;
      leftBorder.receiveShadow = true;
      boardGroup.add(leftBorder);
      
      // Bordure droite
      const rightBorder = new THREE.Mesh(
        new THREE.BoxGeometry(borderThickness, borderHeight, boardDepth),
        borderMaterial
      );
      rightBorder.position.set(boardWidth / 2 - borderThickness / 2, -boardHeight / 2 + borderHeight / 2, 0);
      rightBorder.castShadow = true;
      rightBorder.receiveShadow = true;
      boardGroup.add(rightBorder);
      
      // Charni√®res
      createHinge(-7, 0);
      createHinge(7, 0);
      
      // Trous PEU PROFONDS pour voir les graines
      holeObjects = [];
      const holeRadius = 1.2;
      const holeDepth = 0.5; // Moins profond !
      const spacingX = 2.9;
      const spacingZ = 3.5;
      
      for (let r = 0; r < 2; r++) {
        for (let c = 0; c < 6; c++) {
          const x = -7.25 + c * spacingX;
          const z = r === 0 ? -spacingZ / 2 : spacingZ / 2;
          
          const holeGroup = createHole(x, z, holeRadius, holeDepth, r, c);
          boardGroup.add(holeGroup);
          holeObjects.push(holeGroup);
        }
      }
      
      scene.add(boardGroup);
    }

    function createHinge(x, z) {
      const hingeGeometry = new THREE.BoxGeometry(0.6, 0.25, 1.2);
      const metalMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a4a4a,
        metalness: 0.95,
        roughness: 0.15
      });
      const hinge = new THREE.Mesh(hingeGeometry, metalMaterial);
      hinge.position.set(x, 0.5, z);
      hinge.castShadow = true;
      boardGroup.add(hinge);
      
      // Axe
      const axis = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.08, 1.3, 16),
        metalMaterial
      );
      axis.position.set(x, 0.6, z);
      axis.rotation.x = Math.PI / 2;
      boardGroup.add(axis);
      
      // Vis
      const positions = [[x - 0.2, z - 0.4], [x + 0.2, z - 0.4], [x - 0.2, z + 0.4], [x + 0.2, z + 0.4]];
      positions.forEach(([px, pz]) => {
        const screw = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 0.1, 12),
          new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.9, roughness: 0.2 })
        );
        screw.position.set(px, 0.65, pz);
        screw.rotation.x = Math.PI / 2;
        boardGroup.add(screw);
      });
    }

    function createHole(x, z, radius, depth, row, col) {
      const holeGroup = new THREE.Group();
      holeGroup.position.set(x, 0, z);
      holeGroup.userData = { row, col, isHole: true };
      
      // Parois du trou CLAIRES
      const holeGeometry = new THREE.CylinderGeometry(radius, radius * 0.95, depth, 48);
      const holeMaterial = new THREE.MeshStandardMaterial({
        color: 0xb89968, // Plus clair
        roughness: 0.8,
        metalness: 0
      });
      const hole = new THREE.Mesh(holeGeometry, holeMaterial);
      hole.position.y = -depth / 2 + 0.5;
      hole.receiveShadow = true;
      holeGroup.add(hole);
      
      // Fond du trou CLAIR
      const bottomGeometry = new THREE.CircleGeometry(radius * 0.95, 48);
      const bottomMaterial = new THREE.MeshStandardMaterial({
        color: 0xa68958, // Beaucoup plus clair
        roughness: 0.7
      });
      const bottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
      bottom.rotation.x = -Math.PI / 2;
      bottom.position.y = -depth + 0.5;
      bottom.receiveShadow = true;
      holeGroup.add(bottom);
      
      // Bordure arrondie
      const ringGeometry = new THREE.TorusGeometry(radius, 0.16, 20, 48);
      const ringMaterial = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.7,
        metalness: 0.1
      });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.5;
      ring.castShadow = true;
      ring.receiveShadow = true;
      holeGroup.add(ring);
      
      return holeGroup;
    }

    function createSeed(x, y, z) {
      // Graine TR√àS VISIBLE
      const seedGeometry = new THREE.SphereGeometry(0.28, 24, 24);
      seedGeometry.scale(1, 0.9, 1.1);
      
      const seedColors = [
        0xfff8f0,  // Blanc cass√©
        0xfff0e0,  // Ivoire clair
        0xffe8d0,  // Cr√®me
        0xffd8b8,  // Beige tr√®s clair
        0xf5e6d2   // Beige clair
      ];
      
      const color = seedColors[Math.floor(Math.random() * seedColors.length)];
      
      const seedMaterial = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.5,
        metalness: 0.1,
        emissive: color,
        emissiveIntensity: 0.15 // Graine qui brille
      });
      
      const seed = new THREE.Mesh(seedGeometry, seedMaterial);
      seed.position.set(x, y, z);
      seed.castShadow = true;
      seed.receiveShadow = true;
      
      seed.rotation.x = Math.random() * Math.PI * 2;
      seed.rotation.y = Math.random() * Math.PI * 2;
      seed.rotation.z = Math.random() * Math.PI * 2;
      
      return seed;
    }

    function getHolePosition(row, col) {
      const x = -7.25 + col * 2.9;
      const z = row === 0 ? -1.75 : 1.75;
      return { x, z };
    }

    function positionSeedsInHole(row, col, count) {
      const seeds = [];
      const pos = getHolePosition(row, col);
      
      if (count === 0) return seeds;
      
      for (let i = 0; i < count; i++) {
        let sx, sz, sy;
        
        if (count === 1) {
          sx = pos.x;
          sz = pos.z;
          sy = 0.1; // Plus haut !
        } else if (count <= 4) {
          const angle = (i / count) * Math.PI * 2 + Math.PI / 4;
          const radius = 0.5;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = 0.1;
        } else if (count <= 8) {
          const layer = Math.floor(i / 4);
          const posInLayer = i % 4;
          const angle = (posInLayer / 4) * Math.PI * 2 + Math.PI / 4;
          const radius = layer === 0 ? 0.55 : 0.3;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = 0.1 + layer * 0.35;
        } else {
          const layer = Math.floor(i / 6);
          const posInLayer = i % 6;
          const angle = (posInLayer / 6) * Math.PI * 2;
          const radius = 0.4 + (layer % 2) * 0.25;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = 0.1 + layer * 0.32;
        }
        
        seeds.push({ x: sx, y: sy, z: sz });
      }
      
      return seeds;
    }

    function updateSeeds() {
      seedObjects.forEach(seed => boardGroup.remove(seed));
      seedObjects = [];
      
      for (let r = 0; r < 2; r++) {
        for (let c = 0; c < 6; c++) {
          const count = board[r][c];
          const positions = positionSeedsInHole(r, c, count);
          
          positions.forEach(pos => {
            const seed = createSeed(pos.x, pos.y, pos.z);
            boardGroup.add(seed);
            seedObjects.push(seed);
          });
        }
      }
    }

    function animate3D() {
      requestAnimationFrame(animate3D);
      
      seedObjects.forEach((seed, i) => {
        seed.rotation.y += 0.004 * Math.sin(i * 0.3);
      });
      
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      holeObjects.forEach(hole => {
        hole.children.forEach(child => {
          if (child.material && child.material.emissive) {
            child.material.emissive.setHex(0x000000);
            child.material.emissiveIntensity = 0;
          }
        });
      });
      
      if (intersects.length > 0 && !animating) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          const r = hole.userData.row;
          const c = hole.userData.col;
          
          if ((currentPlayer === 1 && r === 1) || (currentPlayer === 2 && r === 0)) {
            if (board[r][c] > 0) {
              hole.children.forEach(child => {
                if (child.material && child.material.emissive) {
                  child.material.emissive.setHex(0xff8800);
                  child.material.emissiveIntensity = 0.5;
                }
              });
              renderer.domElement.style.cursor = 'pointer';
              return;
            }
          }
        }
      }
      renderer.domElement.style.cursor = 'default';
    }

    function onMouseClick(event) {
      if (animating) return;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      if (intersects.length > 0) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          const r = hole.userData.row;
          const c = hole.userData.col;
          
          if ((currentPlayer === 1 && r === 1) || (currentPlayer === 2 && r === 0)) {
            if (board[r][c] > 0) {
              playClickSound();
              play(r, c);
            }
          }
        }
      }
    }

    function initGame() {
      board = Array.from({ length: 2 }, () => Array(6).fill(4));
      scores = [0, 0];
      currentPlayer = 1;
      animating = false;
      updateDisplay();
      updateSeeds();
    }

    function startTimer() {
      clearTimer();
      if (!timerEnabled) return;
      let rem = timerDuration;
      timerEl.textContent = `Temps: ${rem}s`;
      timerId = setInterval(() => {
        rem--;
        timerEl.textContent = `Temps: ${rem}s`;
        if (rem < 0) {
          clearTimer();
          const loser = currentPlayer;
          const winner = loser === 1 ? 2 : 1;
          const msg = `Temps √©coul√© ! ${pNames[loser - 1]} n'a pas jou√© √† temps.\n${pNames[winner - 1]} remporte la partie.`;
          handleWinner(winner, msg, false);
        }
      }, 1000);
    }

    function clearTimer() {
      clearInterval(timerId);
      timerEl.textContent = '';
    }

    function updateDisplay() {
      p1ScoreEl.textContent = `${pNames[0]}: ${scores[0]}`;
      p2ScoreEl.textContent = `${pNames[1]}: ${scores[1]}`;
      info.textContent = `Tour de ${pNames[currentPlayer - 1]}`;
      startTimer();
    }

    async function animateSeedMovement(seed, startPos, endPos) {
      const duration = 700;
      const startTime = Date.now();
      
      return new Promise(resolve => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const t = Math.min(elapsed / duration, 1);
          
          const easeT = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
          
          const height = 3.5;
          seed.position.x = startPos.x + (endPos.x - startPos.x) * easeT;
          seed.position.z = startPos.z + (endPos.z - startPos.z) * easeT;
          seed.position.y = startPos.y + Math.sin(easeT * Math.PI) * height;
          
          seed.rotation.x += 0.18;
          seed.rotation.y += 0.15;
          seed.rotation.z += 0.12;
          
          if (t < 1) {
            requestAnimationFrame(animate);
          } else {
            seed.position.set(endPos.x, endPos.y, endPos.z);
            resolve();
          }
        }
        animate();
      });
    }

    async function play(r0, c0) {
      if (animating) return;
      animating = true;
      clearTimer();
      
      let seedCount = board[r0][c0];
      if (!seedCount) {
        animating = false;
        return;
      }
      
      board[r0][c0] = 0;
      let idx = parcours.findIndex(p => p[0] === r0 && p[1] === c0);
      
      const startPositions = positionSeedsInHole(r0, c0, seedCount);
      const movingSeeds = [];
      
      for (let i = 0; i < seedCount; i++) {
        const pos = startPositions[i];
        const seed = createSeed(pos.x, pos.y, pos.z);
        boardGroup.add(seed);
        movingSeeds.push(seed);
      }
      
      updateSeeds();
      await new Promise(resolve => setTimeout(resolve, 100));
      
      for (let i = 0; i < movingSeeds.length; i++) {
        const seed = movingSeeds[i];
        idx = (idx + 1) % 12;
        let [r, c] = parcours[idx];
        
        if (r === r0 && c === c0) {
          idx = (idx + 1) % 12;
          [r, c] = parcours[idx];
        }
        
        board[r][c]++;
        
        const startPos = getHolePosition(r0, c0);
        const endPositions = positionSeedsInHole(r, c, board[r][c]);
        const endPos = endPositions[endPositions.length - 1];
        
        playDropSound();
        await animateSeedMovement(seed, startPos, endPos);
        
        boardGroup.remove(seed);
        updateSeeds();
        
        await new Promise(resolve => setTimeout(resolve, 150));
      }
      
      let cap = 0, count = 0, j = idx;
      while (count < 5) {
        let [r, c] = parcours[j];
        if ((currentPlayer === 1 && r === 0) || (currentPlayer === 2 && r === 1)) {
          let v = board[r][c];
          if (v === 2 || v === 3) {
            cap += v;
            playCaptureSound();
            
            const capturePositions = positionSeedsInHole(r, c, v);
            const capturingSeeds = [];
            
            for (let pos of capturePositions) {
              const seed = createSeed(pos.x, pos.y, pos.z);
              boardGroup.add(seed);
              capturingSeeds.push(seed);
            }
            
            board[r][c] = 0;
            updateSeeds();
            
            const captureStart = Date.now();
            const captureDuration = 500;
            
            await new Promise(resolve => {
              function animateCapture() {
                const elapsed = Date.now() - captureStart;
                const progress = Math.min(elapsed / captureDuration, 1);
                
                capturingSeeds.forEach((seed, i) => {
                  const scale = 1 - progress;
                  seed.scale.set(scale, scale, scale);
                  seed.position.y += 0.1;
                  seed.rotation.y += 0.3;
                });
                
                if (progress < 1) {
                  requestAnimationFrame(animateCapture);
                } else {
                  capturingSeeds.forEach(seed => boardGroup.remove(seed));
                  resolve();
                }
              }
              animateCapture();
            });
            
            await new Promise(resolve => setTimeout(resolve, 200));
            
            count++;
            j = (j - 1 + 12) % 12;
            continue;
          }
        }
        break;
      }
      
      scores[currentPlayer - 1] += cap;
      
      const next = currentPlayer === 1 ? 2 : 1;
      const flat = board.flat();
      
      if (flat.every(v => v === 0) || board[next === 1 ? 1 : 0].every(v => v === 0)) {
        const remaining = flat.reduce((a, b) => a + b, 0);
        board = Array.from({ length: 2 }, () => Array(6).fill(0));
        let collector = collectRule === 'current' ? currentPlayer : (currentPlayer === 1 ? 2 : 1);
        const before = scores[collector - 1];
        scores[collector - 1] += remaining;
        const total = scores[collector - 1];
        
        let message = `${pNames[collector - 1]} ramasse ${remaining} graines.\nScore: ${before}+${remaining}=${total}`;
        if (total > 24) message += `\nüéâ ${pNames[collector - 1]} gagne !`;
        else if (total === 24) message += `\n√âGALIT√â 24-24, nouvelle partie !`;
        else message += `\nMoins de 25: ${pNames[(collector === currentPlayer ? next : currentPlayer) - 1]} gagne !`;
        
        handleWinner(collector, message, total === 24);
        animating = false;
        return;
      }
      
      if (scores[currentPlayer - 1] >= 25) {
        handleWinner(currentPlayer, `üéâ ${pNames[currentPlayer - 1]} atteint 25 graines !`, false);
        animating = false;
        return;
      }
      
      currentPlayer = next;
      updateDisplay();
      animating = false;
    }

    function handleWinner(idx, message, isTie = false) {
      clearTimer();
      playWinSound();
      confetti({ particleCount: 400, spread: 120, origin: { y: 0.6 } });
      
      let s1 = scores[0], s2 = scores[1];
      let final = message + `\nScore final: ${s1}-${s2}`;
      
      if (isTie) {
        final += `\nRecommence dans 2s.`;
        timerDuration = Math.max(3, timerDuration - 1);
        info.textContent = final;
        setTimeout(initGame, 2000);
      } else {
        info.textContent = final;
      }
    }

    initThree();
  </script>
</body>
    </html>
