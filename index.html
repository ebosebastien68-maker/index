<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Awal√© 3D Challenge Pro</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { 
      width: 100%; 
      height: 100%; 
      font-family: 'Papyrus', 'Brush Script MT', cursive; 
      background: linear-gradient(135deg, #2c1810 0%, #4a3426 50%, #6b4e3d 100%);
      overflow: hidden;
      touch-action: none;
    }
    
    #canvas-container {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    
    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    #landing, #game-ui {
      position: absolute;
      background: linear-gradient(145deg, rgba(245, 230, 211, 0.95) 0%, rgba(232, 213, 183, 0.95) 100%);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.8), inset 0 2px 5px rgba(255, 255, 255, 0.3);
      border: 5px solid #8b5e3c;
      pointer-events: all;
      backdrop-filter: blur(10px);
    }
    
    #landing {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 380px;
    }
    
    #game-ui {
      top: 0;
      left: 0;
      right: 0;
      transform: none;
      width: 100%;
      max-width: 100%;
      text-align: center;
      padding: 10px 20px;
      border-radius: 0 0 15px 15px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 15px;
    }
    
    h1 { 
      text-align: center; 
      margin-bottom: 25px; 
      color: #3d2817;
      font-size: 3em;
      text-shadow: 3px 3px 6px rgba(0,0,0,0.4), 0 0 20px rgba(139, 94, 60, 0.5);
      letter-spacing: 10px;
      font-weight: bold;
    }
    
    .input-group { 
      margin-bottom: 15px; 
    }
    
    input[type="text"], select, input[type="range"] { 
      width: 100%; 
      padding: 10px; 
      margin-top: 6px;
      border: 3px solid #8b5e3c;
      border-radius: 8px;
      background: #fff;
      font-family: 'Segoe UI', sans-serif;
      font-size: 14px;
    }
    
    label { 
      display: block; 
      font-size: 15px; 
      margin-top: 10px;
      color: #5a3e1b;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
    }
    
    button { 
      width: 100%; 
      padding: 14px; 
      margin-top: 15px; 
      font-size: 18px; 
      background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
      color: #fff; 
      border: none; 
      border-radius: 10px; 
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 6px 20px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255, 255, 255, 0.3);
      transition: transform 0.2s, box-shadow 0.2s;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    }
    
    button:hover { 
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255, 255, 255, 0.4);
    }
    
    button:active {
      transform: scale(0.98);
    }
    
    #info { 
      font-size: 18px; 
      margin: 0;
      color: #3d2817;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
      flex: 1;
      min-width: 150px;
    }
    
    #timer { 
      font-size: 16px; 
      color: #e74c3c; 
      margin: 0;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
      min-width: 100px;
    }
    
    #scores { 
      display: flex; 
      justify-content: center;
      gap: 30px;
      margin: 0;
      font-size: 16px;
      color: #3d2817;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
      flex: 1;
      min-width: 200px;
    }
    
    #restartBtn { 
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
      padding: 8px 20px;
      margin: 0;
      width: auto;
      min-width: 120px;
    }
    
    .btn-chambre-reception {
      display: inline-block;
      width: 100%;
      padding: 14px;
      margin-top: 15px;
      font-size: 16px;
      font-weight: 700;
      text-align: center;
      text-decoration: none;
      color: white;
      border-radius: 10px;
      transition: all 0.3s ease;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      background: linear-gradient(45deg, #FF6B6B, #F06595, #6C5CE7, #48A9A6);
      background-size: 400% 400%;
      animation: gradient-animation 10s ease infinite;
    }
    
    .btn-chambre-reception:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    }
    
    @keyframes gradient-animation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .hidden { display: none !important; }
    
    @media (max-width: 600px) {
      h1 { font-size: 2.2em; letter-spacing: 6px; }
      #landing { padding: 20px; }
      #game-ui { padding: 15px; min-width: 280px; }
      button { padding: 12px; font-size: 16px; }
    }
    
    @media (orientation: portrait) and (max-width: 768px) {
      body::before {
        content: "üîÑ Veuillez tourner votre appareil en mode paysage pour une meilleure exp√©rience";
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        z-index: 10000;
        font-size: 18px;
        max-width: 80%;
        line-height: 1.6;
      }
    }
    
    .turn-indicator {
      position: absolute;
      font-size: 100px;
      pointer-events: none;
      z-index: 100;
      animation: pointPulse 1.5s ease-in-out infinite;
      filter: drop-shadow(4px 4px 8px rgba(0,0,0,0.6));
      transition: all 0.5s ease;
    }
    
    .turn-indicator.player1 {
      bottom: 50%;
      right: 3%;
      transform: translateY(50%) rotate(0deg);
    }
    
    .turn-indicator.player2 {
      top: 50%;
      right: 3%;
      transform: translateY(-50%) rotate(180deg);
    }
    
    @keyframes pointPulse {
      0%, 100% { 
        filter: drop-shadow(4px 4px 8px rgba(0,0,0,0.6));
      }
      50% { 
        filter: drop-shadow(6px 6px 12px rgba(255,165,0,0.9));
      }
    }
    
    .seed-count-tooltip {
      position: absolute;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(30, 20, 10, 0.95));
      color: #FFD700;
      padding: 15px 25px;
      border-radius: 12px;
      font-size: 32px;
      font-weight: bold;
      pointer-events: none;
      z-index: 1000;
      box-shadow: 0 6px 20px rgba(0,0,0,0.7);
      border: 3px solid #FFD700;
      animation: tooltipAppear 0.3s ease;
    }
    
    @keyframes tooltipAppear {
      from { opacity: 0; transform: scale(0.8); }
      to { opacity: 1; transform: scale(1); }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="ui-overlay">
    <div id="landing">
      <h1>AWAL√â</h1>
      <div class="input-group">
        <label>Nom Joueur 1</label>
        <input type="text" id="player1" placeholder="Joueur 1">
      </div>
      <div class="input-group">
        <label>Nom Joueur 2</label>
        <input type="text" id="player2" placeholder="Joueur 2">
      </div>
      <div class="input-group">
        <label>Qui ramasse les graines restantes ?</label>
        <select id="collectRule">
          <option value="current">Joueur actif</option>
          <option value="opponent">Adversaire</option>
        </select>
      </div>
      <div class="input-group">
        <label><input type="checkbox" id="enableTimer"> Activer compte √† rebours</label>
      </div>
      <div class="input-group">
        <label>Dur√©e (3‚Äì10s) : <span id="delayValue">5</span>s</label>
        <input type="range" id="delayRange" min="3" max="10" value="5">
      </div>
      <button id="startBtn">Commencer la partie</button>
      <a href="chambre.html" class="btn-chambre-reception">Acc√©der √† la chambre de r√©ception</a>
    </div>

    <div id="game-ui" class="hidden">
      <div id="info"></div>
      <div id="scores"><span id="p1Score"></span><span id="p2Score"></span></div>
      <div id="timer"></div>
      <button id="restartBtn">Recommencer</button>
    </div>
    
    <div id="turnIndicator" class="turn-indicator hidden">‚òùÔ∏è</div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  
  <script>
    let scene, camera, renderer, raycaster, mouse;
    let boardGroup, holeObjects = [], seedObjects = [];
    let board, currentPlayer, scores, pNames, collectRule;
    let timerEnabled, timerDuration, timerId;
    let animating = false;
    let longPressTimer = null;
    let longPressTarget = null;
    
    const landing = document.getElementById('landing');
    const gameUI = document.getElementById('game-ui');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const info = document.getElementById('info');
    const timerEl = document.getElementById('timer');
    const p1ScoreEl = document.getElementById('p1Score');
    const p2ScoreEl = document.getElementById('p2Score');
    const delayRange = document.getElementById('delayRange');
    const delayValue = document.getElementById('delayValue');
    const collectRuleSel = document.getElementById('collectRule');
    const turnIndicator = document.getElementById('turnIndicator');
    
    const parcours = [[1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0]];

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(freq, duration, type = 'sine', volume = 0.3) {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = freq;
      oscillator.type = type;
      
      gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    }
    
    function playClickSound() { playSound(900, 0.08, 'sine', 0.25); }
    function playDropSound() { playSound(450, 0.12, 'triangle', 0.2); }
    function playCaptureSound() {
      playSound(650, 0.18, 'square', 0.25);
      setTimeout(() => playSound(750, 0.15, 'square', 0.2), 40);
      setTimeout(() => playSound(850, 0.12, 'sine', 0.18), 80);
    }
    function playWinSound() {
      playSound(523, 0.2, 'sine', 0.3);
      setTimeout(() => playSound(659, 0.2, 'sine', 0.3), 120);
      setTimeout(() => playSound(784, 0.35, 'sine', 0.35), 240);
    }

    delayRange.oninput = () => delayValue.textContent = delayRange.value;

    startBtn.onclick = () => {
      playClickSound();
      pNames = [document.getElementById('player1').value || 'Joueur 1', document.getElementById('player2').value || 'Joueur 2'];
      collectRule = collectRuleSel.value;
      timerEnabled = document.getElementById('enableTimer').checked;
      timerDuration = parseInt(delayRange.value);
      landing.classList.add('hidden');
      gameUI.classList.remove('hidden');
      initGame();
    };

    restartBtn.onclick = () => {
      playClickSound();
      initGame();
    };

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1410);
      
      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
      
      if (aspect < 1.2) {
        camera.position.set(0, 18, 18);
        camera.fov = 55;
      } else {
        camera.position.set(0, 15, 16);
        camera.fov = 45;
      }
      camera.updateProjectionMatrix();
      camera.lookAt(0, 0, 0);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.physicallyCorrectLights = true;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.3;
      document.getElementById('canvas-container').appendChild(renderer.domElement);
      
      const ambientLight = new THREE.AmbientLight(0xfff8f0, 2.5);
      scene.add(ambientLight);
      
      const mainLight = new THREE.DirectionalLight(0xfff5e6, 3.5);
      mainLight.position.set(12, 30, 15);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 4096;
      mainLight.shadow.mapSize.height = 4096;
      mainLight.shadow.camera.left = -35;
      mainLight.shadow.camera.right = 35;
      mainLight.shadow.camera.top = 35;
      mainLight.shadow.camera.bottom = -35;
      mainLight.shadow.bias = -0.0002;
      mainLight.shadow.radius = 3;
      scene.add(mainLight);
      
      const fillLight1 = new THREE.PointLight(0xfff8f0, 2.5, 50);
      fillLight1.position.set(-10, 8, -5);
      scene.add(fillLight1);
      
      const fillLight2 = new THREE.PointLight(0xfff8f0, 2.5, 50);
      fillLight2.position.set(10, 8, 5);
      scene.add(fillLight2);
      
      const spotLight1 = new THREE.SpotLight(0xffffff, 1.8, 50, Math.PI / 6, 0.3, 1);
      spotLight1.position.set(0, 20, 0);
      spotLight1.target.position.set(0, 0, 0);
      scene.add(spotLight1);
      scene.add(spotLight1.target);
      
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x6b4e3d, 1.2);
      scene.add(hemiLight);
      
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      window.addEventListener('resize', onWindowResize);
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('mousedown', onMouseDown);
      renderer.domElement.addEventListener('mouseup', onMouseUp);
      renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
      renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
      
      createBoard();
      animate3D();
    }

    function createWoodTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 2048;
      canvas.height = 2048;
      const ctx = canvas.getContext('2d');
      
      const gradient = ctx.createLinearGradient(0, 0, 2048, 2048);
      gradient.addColorStop(0, '#8B4513');
      gradient.addColorStop(0.3, '#A0522D');
      gradient.addColorStop(0.6, '#8B6914');
      gradient.addColorStop(1, '#654321');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 2048, 2048);
      
      for (let i = 0; i < 300; i++) {
        ctx.strokeStyle = `rgba(${20 + Math.random() * 40}, ${10 + Math.random() * 20}, ${5 + Math.random() * 15}, ${0.15 + Math.random() * 0.35})`;
        ctx.lineWidth = 0.8 + Math.random() * 3;
        ctx.beginPath();
        const startX = Math.random() * 2048;
        ctx.moveTo(startX, 0);
        
        for (let j = 0; j < 12; j++) {
          const cpX = startX + (Math.random() - 0.5) * 600;
          const cpY = j * 200 + (Math.random() - 0.5) * 150;
          const endX = startX + (Math.random() - 0.5) * 700;
          const endY = (j + 1) * 200;
          ctx.quadraticCurveTo(cpX, cpY, endX, endY);
        }
        ctx.stroke();
      }
      
      for (let i = 0; i < 50; i++) {
        const x = Math.random() * 2048;
        const y = Math.random() * 2048;
        const radius = 30 + Math.random() * 60;
        
        for (let ring = 8; ring > 0; ring--) {
          const grad = ctx.createRadialGradient(x, y, 0, x, y, radius * ring / 8);
          grad.addColorStop(0, `rgba(40, 25, 15, ${0.25 * ring / 8})`);
          grad.addColorStop(1, 'rgba(40, 25, 15, 0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(x, y, radius * ring / 8, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      for (let i = 0; i < 15000; i++) {
        const x = Math.random() * 2048;
        const y = Math.random() * 2048;
        ctx.fillStyle = `rgba(${50 + Math.random() * 50}, ${30 + Math.random() * 30}, ${15 + Math.random() * 20}, ${0.05 + Math.random() * 0.15})`;
        ctx.fillRect(x, y, 1 + Math.random() * 2, 0.6 + Math.random() * 1);
      }
      
      const glossGrad = ctx.createLinearGradient(0, 0, 2048, 2048);
      glossGrad.addColorStop(0, 'rgba(255, 255, 255, 0.12)');
      glossGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.05)');
      glossGrad.addColorStop(1, 'rgba(255, 255, 255, 0.12)');
      ctx.fillStyle = glossGrad;
      ctx.fillRect(0, 0, 2048, 2048);
      
      const texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      return texture;
    }

    function createBoard() {
      boardGroup = new THREE.Group();
      
      const boardWidth = 22;
      const boardDepth = 10;
      const boardHeight = 2;
      const borderHeight = 1.8;
      const borderThickness = 1.2;
      
      const woodTexture = createWoodTexture();
      
      const baseGeometry = new THREE.BoxGeometry(boardWidth, 0.8, boardDepth);
      const baseMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture,
        color: 0x8B4513,
        roughness: 0.6,
        metalness: 0.1,
        envMapIntensity: 0.6
      });
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = -boardHeight / 2 - 0.4;
      base.receiveShadow = true;
      base.castShadow = true;
      boardGroup.add(base);
      
      const innerGeometry = new THREE.BoxGeometry(
        boardWidth - borderThickness * 2,
        0.6,
        boardDepth - borderThickness * 2
      );
      const innerMaterial = new THREE.MeshStandardMaterial({
        color: 0xD2B48C,
        roughness: 0.4,
        metalness: 0.15,
        emissive: 0xD2B48C,
        emissiveIntensity: 0.25,
        clearcoat: 0.4,
        clearcoatRoughness: 0.3
      });
      const inner = new THREE.Mesh(innerGeometry, innerMaterial);
      inner.position.y = -boardHeight / 2 + 0.6;
      inner.receiveShadow = true;
      boardGroup.add(inner);
      
      const borderMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture,
        color: 0x654321,
        roughness: 0.65,
        metalness: 0.12,
        clearcoat: 0.5,
        clearcoatRoughness: 0.2
      });
      
      const topBorder = new THREE.Mesh(
        new THREE.BoxGeometry(boardWidth, borderHeight, borderThickness),
        borderMaterial
      );
      topBorder.position.set(0, -boardHeight / 2 + borderHeight / 2, -boardDepth / 2 + borderThickness / 2);
      topBorder.castShadow = true;
      topBorder.receiveShadow = true;
      boardGroup.add(topBorder);
      
      const bottomBorder = new THREE.Mesh(
        new THREE.BoxGeometry(boardWidth, borderHeight, borderThickness),
        borderMaterial
      );
      bottomBorder.position.set(0, -boardHeight / 2 + borderHeight / 2, boardDepth / 2 - borderThickness / 2);
      bottomBorder.castShadow = true;
      bottomBorder.receiveShadow = true;
      boardGroup.add(bottomBorder);
      
      const leftBorder = new THREE.Mesh(
        new THREE.BoxGeometry(borderThickness, borderHeight, boardDepth),
        borderMaterial
      );
      leftBorder.position.set(-boardWidth / 2 + borderThickness / 2, -boardHeight / 2 + borderHeight / 2, 0);
      leftBorder.castShadow = true;
      leftBorder.receiveShadow = true;
      boardGroup.add(leftBorder);
      
      const rightBorder = new THREE.Mesh(
        new THREE.BoxGeometry(borderThickness, borderHeight, boardDepth),
        borderMaterial
      );
      rightBorder.position.set(boardWidth / 2 - borderThickness / 2, -boardHeight / 2 + borderHeight / 2, 0);
      rightBorder.castShadow = true;
      rightBorder.receiveShadow = true;
      boardGroup.add(rightBorder);
      
      createHinge(-8.5, 0);
      createHinge(8.5, 0);
      
      holeObjects = [];
      const holeRadius = 1.35;
      const holeDepth = 1.8;
      const spacingX = 3.3;
      const spacingZ = 4;
      
      for (let r = 0; r < 2; r++) {
        for (let c = 0; c < 6; c++) {
          const x = -8.25 + c * spacingX;
          const z = r === 0 ? -spacingZ / 2 : spacingZ / 2;
          
          const holeGroup = createHole(x, z, holeRadius, holeDepth, r, c);
          boardGroup.add(holeGroup);
          holeObjects.push(holeGroup);
        }
      }
      
      scene.add(boardGroup);
    }

    function createHinge(x, z) {
      const hingeGeometry = new THREE.BoxGeometry(0.8, 0.35, 1.5);
      const metalMaterial = new THREE.MeshStandardMaterial({
        color: 0x2c2c2c,
        metalness: 1.0,
        roughness: 0.1,
        envMapIntensity: 2.0
      });
      const hinge = new THREE.Mesh(hingeGeometry, metalMaterial);
      hinge.position.set(x, 0.7, z);
      hinge.castShadow = true;
      boardGroup.add(hinge);
      
      const axis = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 1.6, 24),
        metalMaterial
      );
      axis.position.set(x, 0.85, z);
      axis.rotation.x = Math.PI / 2;
      boardGroup.add(axis);
      
      const screwMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x0a0a0a, 
        metalness: 1.0, 
        roughness: 0.12 
      });
      
      const positions = [[x - 0.3, z - 0.6], [x + 0.3, z - 0.6], [x - 0.3, z + 0.6], [x + 0.3, z + 0.6]];
      positions.forEach(([px, pz]) => {
        const screw = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.15, 20),
          screwMaterial
        );
        screw.position.set(px, 0.9, pz);
        screw.rotation.x = Math.PI / 2;
        boardGroup.add(screw);
        
        const slotGeometry = new THREE.BoxGeometry(0.18, 0.025, 0.025);
        const slot1 = new THREE.Mesh(slotGeometry, screwMaterial);
        slot1.position.set(px, 0.98, pz);
        boardGroup.add(slot1);
        
        const slot2 = new THREE.Mesh(slotGeometry, screwMaterial);
        slot2.position.set(px, 0.98, pz);
        slot2.rotation.y = Math.PI / 2;
        boardGroup.add(slot2);
      });
    }

    function createHole(x, z, radius, depth, row, col) {
      const holeGroup = new THREE.Group();
      holeGroup.position.set(x, 0, z);
      holeGroup.userData = { row, col, isHole: true };
      
      const holeGeometry = new THREE.CylinderGeometry(radius, radius * 0.88, depth, 64);
      const holeMaterial = new THREE.MeshStandardMaterial({
        color: 0x2d1810,
        roughness: 0.85,
        metalness: 0.02,
        emissive: 0x1a0a05,
        emissiveIntensity: 0.08
      });
      const hole = new THREE.Mesh(holeGeometry, holeMaterial);
      hole.position.y = -depth / 2 + 0.6;
      hole.receiveShadow = true;
      holeGroup.add(hole);
      
      const bottomGeometry = new THREE.CircleGeometry(radius * 0.88, 64);
      const bottomMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a0f08,
        roughness: 0.95,
        metalness: 0.0,
        emissive: 0x0a0503,
        emissiveIntensity: 0.03
      });
      const bottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
      bottom.rotation.x = -Math.PI / 2;
      bottom.position.y = -depth + 0.6;
      bottom.receiveShadow = true;
      holeGroup.add(bottom);
      
      const ringGeometry = new THREE.TorusGeometry(radius, 0.22, 36, 64);
      const ringMaterial = new THREE.MeshStandardMaterial({
        color: 0x5C4033,
        roughness: 0.25,
        metalness: 0.35,
        clearcoat: 0.9,
        clearcoatRoughness: 0.08
      });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.6;
      ring.castShadow = true;
      ring.receiveShadow = true;
      holeGroup.add(ring);
      
      return holeGroup;
    }

    function createSeed(x, y, z) {
      const seedGroup = new THREE.Group();
      
      const seedGeometry = new THREE.SphereGeometry(0.38, 48, 48);
      seedGeometry.scale(1, 0.9, 1.1);
      
      const seedColors = [
        { base: 0xFFD700, light: 0xFFE55C },
        { base: 0xFFA500, light: 0xFFBF3F },
        { base: 0xFF8C00, light: 0xFFA433 },
        { base: 0xF4A460, light: 0xF7BC7D },
        { base: 0xDAA520, light: 0xE6B84D },
        { base: 0xFFB347, light: 0xFFC46B },
        { base: 0xFF7F50, light: 0xFF9A7A },
        { base: 0xFFA07A, light: 0xFFB599 }
      ];
      
      const colorPair = seedColors[Math.floor(Math.random() * seedColors.length)];
      
      const seedMaterial = new THREE.MeshStandardMaterial({
        color: colorPair.base,
        roughness: 0.2,
        metalness: 0.4,
        emissive: colorPair.light,
        emissiveIntensity: 0.6,
        clearcoat: 0.8,
        clearcoatRoughness: 0.15
      });
      
      const seed = new THREE.Mesh(seedGeometry, seedMaterial);
      seed.castShadow = true;
      seed.receiveShadow = true;
      
      seed.rotation.x = Math.random() * Math.PI * 2;
      seed.rotation.y = Math.random() * Math.PI * 2;
      seed.rotation.z = Math.random() * Math.PI * 2;
      
      seedGroup.add(seed);
      
      const glowLight = new THREE.PointLight(colorPair.light, 0.8, 2);
      glowLight.position.set(0, 0, 0);
      seedGroup.add(glowLight);
      
      seedGroup.position.set(x, y, z);
      
      return seedGroup;
    }

    function getHolePosition(row, col) {
      const x = -8.25 + col * 3.3;
      const z = row === 0 ? -2 : 2;
      return { x, z };
    }

    function positionSeedsInHole(row, col, count) {
      const seeds = [];
      const pos = getHolePosition(row, col);
      
      if (count === 0) return seeds;
      
      const baseY = 1.2;
      
      for (let i = 0; i < count; i++) {
        let sx, sz, sy;
        
        if (count === 1) {
          sx = pos.x;
          sz = pos.z;
          sy = baseY;
        } else if (count <= 4) {
          const angle = (i / count) * Math.PI * 2 + Math.PI / 4;
          const radius = 0.48;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = baseY;
        } else if (count <= 8) {
          const layer = Math.floor(i / 4);
          const posInLayer = i % 4;
          const angle = (posInLayer / 4) * Math.PI * 2 + Math.PI / 4;
          const radius = layer === 0 ? 0.52 : 0.28;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = baseY + layer * 0.45;
        } else {
          const layer = Math.floor(i / 6);
          const posInLayer = i % 6;
          const angle = (posInLayer / 6) * Math.PI * 2;
          const radius = 0.38 + (layer % 2) * 0.28;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = baseY + layer * 0.42;
        }
        
        seeds.push({ x: sx, y: sy, z: sz });
      }
      
      return seeds;
    }

    function updateSeeds() {
      seedObjects.forEach(seed => boardGroup.remove(seed));
      seedObjects = [];
      
      for (let r = 0; r < 2; r++) {
        for (let c = 0; c < 6; c++) {
          const count = board[r][c];
          const positions = positionSeedsInHole(r, c, count);
          
          positions.forEach(pos => {
            const seed = createSeed(pos.x, pos.y, pos.z);
            boardGroup.add(seed);
            seedObjects.push(seed);
          });
        }
      }
    }

    function animate3D() {
      requestAnimationFrame(animate3D);
      
      seedObjects.forEach((seed, i) => {
        seed.children[0].rotation.y += 0.004 * Math.sin(i * 0.3);
        seed.position.y += Math.sin(Date.now() * 0.0012 + i * 0.6) * 0.0012;
      });
      
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;
      camera.aspect = aspect;
      
      if (aspect < 1.2) {
        camera.fov = 55;
        camera.position.set(0, 18, 18);
      } else if (aspect < 1.5) {
        camera.fov = 50;
        camera.position.set(0, 16, 17);
      } else {
        camera.fov = 45;
        camera.position.set(0, 15, 16);
      }
      
      camera.updateProjectionMatrix();
      camera.lookAt(0, 0, 0);
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    let touchStartPos = null;

    function onTouchStart(event) {
      event.preventDefault();
      if (animating) return;
      
      const touch = event.touches[0];
      touchStartPos = { x: touch.clientX, y: touch.clientY };
      
      mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      if (intersects.length > 0) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          longPressTarget = hole;
          longPressTimer = setTimeout(() => {
            showSeedCount(hole, touch.clientX, touch.clientY);
          }, 500);
        }
      }
    }

    function onTouchEnd(event) {
      event.preventDefault();
      
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      
      const tooltip = document.querySelector('.seed-count-tooltip');
      if (tooltip) tooltip.remove();
      
      if (animating || !touchStartPos) return;
      
      const touch = event.changedTouches[0];
      const dx = touch.clientX - touchStartPos.x;
      const dy = touch.clientY - touchStartPos.y;
      
      if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(holeObjects, true);
        
        if (intersects.length > 0) {
          let hole = intersects[0].object;
          while (hole.parent && !hole.userData.isHole) {
            hole = hole.parent;
          }
          
          if (hole.userData.isHole) {
            const r = hole.userData.row;
            const c = hole.userData.col;
            
            if ((currentPlayer === 1 && r === 1) || (currentPlayer === 2 && r === 0)) {
              if (board[r][c] > 0) {
                playClickSound();
                play(r, c);
              }
            }
          }
        }
      }
      
      touchStartPos = null;
      longPressTarget = null;
    }
    
    function showSeedCount(hole, x, y) {
      const r = hole.userData.row;
      const c = hole.userData.col;
      const count = board[r][c];
      
      const tooltip = document.createElement('div');
      tooltip.className = 'seed-count-tooltip';
      tooltip.textContent = `üå∞ ${count}`;
      tooltip.style.left = x + 'px';
      tooltip.style.top = (y - 70) + 'px';
      
      document.body.appendChild(tooltip);
      
      if (navigator.vibrate) {
        navigator.vibrate(50);
      }
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      holeObjects.forEach(hole => {
        hole.children.forEach(child => {
          if (child.material && child.material.emissive) {
            child.material.emissive.setHex(child.material.color.getHex());
            child.material.emissiveIntensity = child === hole.children[1] ? 0.03 : 0.08;
          }
        });
      });
      
      if (intersects.length > 0 && !animating) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          const r = hole.userData.row;
          const c = hole.userData.col;
          
          if ((currentPlayer === 1 && r === 1) || (currentPlayer === 2 && r === 0)) {
            if (board[r][c] > 0) {
              hole.children.forEach(child => {
                if (child.material && child.material.emissive) {
                  child.material.emissive.setHex(0xff6600);
                  child.material.emissiveIntensity = 0.8;
                }
              });
              renderer.domElement.style.cursor = 'pointer';
              return;
            }
          }
        }
      }
      renderer.domElement.style.cursor = 'default';
    }
    
    function onMouseDown(event) {
      if (animating) return;
      
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      if (intersects.length > 0) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          longPressTarget = hole;
          longPressTimer = setTimeout(() => {
            showSeedCount(hole, event.clientX, event.clientY);
          }, 500);
        }
      }
    }
    
    function onMouseUp(event) {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      
      const tooltip = document.querySelector('.seed-count-tooltip');
      if (tooltip) tooltip.remove();
      
      longPressTarget = null;
    }

    function onMouseClick(event) {
      if (animating) return;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      if (intersects.length > 0) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          const r = hole.userData.row;
          const c = hole.userData.col;
          
          if ((currentPlayer === 1 && r === 1) || (currentPlayer === 2 && r === 0)) {
            if (board[r][c] > 0) {
              playClickSound();
              play(r, c);
            }
          }
        }
      }
    }

    function initGame() {
      board = Array.from({ length: 2 }, () => Array(6).fill(4));
      scores = [0, 0];
      currentPlayer = 1;
      animating = false;
      updateDisplay();
      updateSeeds();
    }

    function startTimer() {
      clearTimer();
      if (!timerEnabled) return;
      let rem = timerDuration;
      timerEl.textContent = `Temps: ${rem}s`;
      timerId = setInterval(() => {
        rem--;
        timerEl.textContent = `Temps: ${rem}s`;
        if (rem < 0) {
          clearTimer();
          const loser = currentPlayer;
          const winner = loser === 1 ? 2 : 1;
          const msg = `Temps √©coul√© ! ${pNames[loser - 1]} n'a pas jou√© √† temps.\n${pNames[winner - 1]} remporte la partie.`;
          handleWinner(winner, msg, false);
        }
      }, 1000);
    }

    function clearTimer() {
      clearInterval(timerId);
      timerEl.textContent = '';
    }

    function updateDisplay() {
      p1ScoreEl.textContent = `${pNames[0]}: ${scores[0]}`;
      p2ScoreEl.textContent = `${pNames[1]}: ${scores[1]}`;
      info.textContent = `Tour de ${pNames[currentPlayer - 1]}`;
      
      turnIndicator.classList.remove('hidden', 'player1', 'player2');
      turnIndicator.classList.add(currentPlayer === 1 ? 'player1' : 'player2');
      
      startTimer();
    }

    async function animateSeedMovement(seed, startPos, endPos) {
      const duration = 700;
      const startTime = Date.now();
      
      return new Promise(resolve => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const t = Math.min(elapsed / duration, 1);
          
          const easeT = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
          
          const height = 4.2;
          seed.position.x = startPos.x + (endPos.x - startPos.x) * easeT;
          seed.position.z = startPos.z + (endPos.z - startPos.z) * easeT;
          seed.position.y = startPos.y + Math.sin(easeT * Math.PI) * height;
          
          seed.children[0].rotation.x += 0.22;
          seed.children[0].rotation.y += 0.19;
          seed.children[0].rotation.z += 0.15;
          
          if (t < 1) {
            requestAnimationFrame(animate);
          } else {
            seed.position.set(endPos.x, endPos.y, endPos.z);
            resolve();
          }
        }
        animate();
      });
    }

    async function play(r0, c0) {
      if (animating) return;
      animating = true;
      clearTimer();
      
      let seedCount = board[r0][c0];
      if (!seedCount) {
        animating = false;
        return;
      }
      
      board[r0][c0] = 0;
      let idx = parcours.findIndex(p => p[0] === r0 && p[1] === c0);
      
      const startPositions = positionSeedsInHole(r0, c0, seedCount);
      const movingSeeds = [];
      
      for (let i = 0; i < seedCount; i++) {
        const pos = startPositions[i];
        const seed = createSeed(pos.x, pos.y, pos.z);
        boardGroup.add(seed);
        movingSeeds.push(seed);
      }
      
      updateSeeds();
      await new Promise(resolve => setTimeout(resolve, 150));
      
      for (let i = 0; i < movingSeeds.length; i++) {
        const seed = movingSeeds[i];
        idx = (idx + 1) % 12;
        let [r, c] = parcours[idx];
        
        if (r === r0 && c === c0) {
          idx = (idx + 1) % 12;
          [r, c] = parcours[idx];
        }
        
        board[r][c]++;
        
        const startPos = getHolePosition(r0, c0);
        const endPositions = positionSeedsInHole(r, c, board[r][c]);
        const endPos = endPositions[endPositions.length - 1];
        
        playDropSound();
        await animateSeedMovement(seed, startPos, endPos);
        
        boardGroup.remove(seed);
        updateSeeds();
        
        await new Promise(resolve => setTimeout(resolve, 160));
      }
      
      let cap = 0, count = 0, j = idx;
      while (count < 5) {
        let [r, c] = parcours[j];
        if ((currentPlayer === 1 && r === 0) || (currentPlayer === 2 && r === 1)) {
          let v = board[r][c];
          if (v === 2 || v === 3) {
            cap += v;
            playCaptureSound();
            
            const capturePositions = positionSeedsInHole(r, c, v);
            const capturingSeeds = [];
            
            for (let pos of capturePositions) {
              const seed = createSeed(pos.x, pos.y, pos.z);
              boardGroup.add(seed);
              capturingSeeds.push(seed);
            }
            
            board[r][c] = 0;
            updateSeeds();
            
            const captureStart = Date.now();
            const captureDuration = 500;
            
            await new Promise(resolve => {
              function animateCapture() {
                const elapsed = Date.now() - captureStart;
                const progress = Math.min(elapsed / captureDuration, 1);
                
                capturingSeeds.forEach((seed, i) => {
                  const scale = 1 - progress;
                  seed.scale.set(scale, scale, scale);
                  seed.position.y += 0.15;
                  seed.children[0].rotation.y += 0.4;
                  seed.children[0].rotation.x += 0.3;
                });
                
                if (progress < 1) {
                  requestAnimationFrame(animateCapture);
                } else {
                  capturingSeeds.forEach(seed => boardGroup.remove(seed));
                  resolve();
                }
              }
              animateCapture();
            });
            
            await new Promise(resolve => setTimeout(resolve, 200));
            
            count++;
            j = (j - 1 + 12) % 12;
            continue;
          }
        }
        break;
      }
      
      scores[currentPlayer - 1] += cap;
      
      const next = currentPlayer === 1 ? 2 : 1;
      const flat = board.flat();
      
      if (flat.every(v => v === 0) || board[next === 1 ? 1 : 0].every(v => v === 0)) {
        const remaining = flat.reduce((a, b) => a + b, 0);
        board = Array.from({ length: 2 }, () => Array(6).fill(0));
        let collector = collectRule === 'current' ? currentPlayer : (currentPlayer === 1 ? 2 : 1);
        const before = scores[collector - 1];
        scores[collector - 1] += remaining;
        const total = scores[collector - 1];
        
        let message = `${pNames[collector - 1]} ramasse ${remaining} graines.\nScore: ${before}+${remaining}=${total}`;
        if (total > 24) message += `\nüéâ ${pNames[collector - 1]} gagne !`;
        else if (total === 24) message += `\n√âGALIT√â 24-24, nouvelle partie !`;
        else message += `\nMoins de 25: ${pNames[(collector === currentPlayer ? next : currentPlayer) - 1]} gagne !`;
        
        handleWinner(collector, message, total === 24);
        animating = false;
        return;
      }
      
      if (scores[currentPlayer - 1] >= 25) {
        handleWinner(currentPlayer, `üéâ ${pNames[currentPlayer - 1]} atteint 25 graines !`, false);
        animating = false;
        return;
      }
      
      currentPlayer = next;
      updateDisplay();
      animating = false;
    }

    function handleWinner(idx, message, isTie = false) {
      clearTimer();
      playWinSound();
      confetti({ 
        particleCount: 600, 
        spread: 160, 
        origin: { y: 0.6 },
        colors: ['#FFD700', '#FFA500', '#FF6347', '#FF69B4', '#00CED1', '#7FFF00']
      });
      
      let s1 = scores[0], s2 = scores[1];
      let final = message + `\nScore final: ${s1}-${s2}`;
      
      if (isTie) {
        final += `\nRecommence dans 2s.`;
        timerDuration = Math.max(3, timerDuration - 1);
        info.textContent = final;
        setTimeout(initGame, 2000);
      } else {
        info.textContent = final;
      }
    }

    initThree();
  </script>
</body>
  </html>
