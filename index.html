<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Awal√© 3D Challenge Pro</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body, html { 
      width: 100%; 
      height: 100%; 
      font-family: 'Papyrus', 'Brush Script MT', cursive; 
      background: linear-gradient(135deg, #f5e6d3 0%, #e8d5b7 50%, #d4c5a9 100%);
      overflow: hidden;
      touch-action: none;
    }
    
    #canvas-container {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    
    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    #landing, #game-ui {
      position: absolute;
      background: linear-gradient(145deg, #f5e6d3 0%, #e8d5b7 100%);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 15px 50px rgba(90, 62, 27, 0.7), inset 0 2px 5px rgba(255, 255, 255, 0.3);
      border: 5px solid #8b5e3c;
      pointer-events: all;
    }
    
    #landing {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 380px;
    }
    
    #game-ui {
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: auto;
      min-width: 300px;
      max-width: 90%;
      text-align: center;
      padding: 20px;
    }
    
    h1 { 
      text-align: center; 
      margin-bottom: 25px; 
      color: #3d2817;
      font-size: 3em;
      text-shadow: 3px 3px 6px rgba(0,0,0,0.4), 0 0 20px rgba(139, 94, 60, 0.5);
      letter-spacing: 10px;
      font-weight: bold;
    }
    
    .input-group { 
      margin-bottom: 15px; 
    }
    
    input[type="text"], select, input[type="range"] { 
      width: 100%; 
      padding: 10px; 
      margin-top: 6px;
      border: 3px solid #8b5e3c;
      border-radius: 8px;
      background: #fff;
      font-family: 'Segoe UI', sans-serif;
      font-size: 14px;
    }
    
    label { 
      display: block; 
      font-size: 15px; 
      margin-top: 10px;
      color: #5a3e1b;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
    }
    
    button { 
      width: 100%; 
      padding: 14px; 
      margin-top: 15px; 
      font-size: 18px; 
      background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
      color: #fff; 
      border: none; 
      border-radius: 10px; 
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 6px 20px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255, 255, 255, 0.3);
      transition: transform 0.2s, box-shadow 0.2s;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
    }
    
    button:hover { 
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255, 255, 255, 0.4);
    }
    
    button:active {
      transform: scale(0.98);
    }
    
    #info { 
      font-size: 20px; 
      margin-bottom: 10px;
      color: #3d2817;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
    }
    
    #timer { 
      font-size: 18px; 
      color: #e74c3c; 
      margin-bottom: 10px;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
    }
    
    #scores { 
      display: flex; 
      justify-content: space-around; 
      margin-bottom: 10px; 
      font-size: 18px;
      color: #3d2817;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
    }
    
    #restartBtn { 
      background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    }
    
    .btn-chambre-reception {
      display: inline-block;
      width: 100%;
      padding: 14px;
      margin-top: 15px;
      font-size: 16px;
      font-weight: 700;
      text-align: center;
      text-decoration: none;
      color: white;
      border-radius: 10px;
      transition: all 0.3s ease;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      background: linear-gradient(45deg, #FF6B6B, #F06595, #6C5CE7, #48A9A6);
      background-size: 400% 400%;
      animation: gradient-animation 10s ease infinite;
    }
    
    .btn-chambre-reception:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    }
    
    @keyframes gradient-animation {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .hidden { display: none !important; }
    
    @media (max-width: 600px) {
      h1 { font-size: 2.2em; letter-spacing: 6px; }
      #landing { padding: 20px; }
      #game-ui { padding: 15px; min-width: 280px; }
      button { padding: 12px; font-size: 16px; }
    }
    
    @media (orientation: portrait) and (max-width: 768px) {
      body::before {
        content: "üîÑ Veuillez tourner votre appareil en mode paysage pour une meilleure exp√©rience";
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        z-index: 10000;
        font-size: 18px;
        max-width: 80%;
        line-height: 1.6;
      }
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  
  <div id="ui-overlay">
    <div id="landing">
      <h1>AWAL√â</h1>
      <div class="input-group">
        <label>Nom Joueur 1</label>
        <input type="text" id="player1" placeholder="Joueur 1">
      </div>
      <div class="input-group">
        <label>Nom Joueur 2</label>
        <input type="text" id="player2" placeholder="Joueur 2">
      </div>
      <div class="input-group">
        <label>Qui ramasse les graines restantes ?</label>
        <select id="collectRule">
          <option value="current">Joueur actif</option>
          <option value="opponent">Adversaire</option>
        </select>
      </div>
      <div class="input-group">
        <label><input type="checkbox" id="enableTimer"> Activer compte √† rebours</label>
      </div>
      <div class="input-group">
        <label>Dur√©e (3‚Äì10s) : <span id="delayValue">5</span>s</label>
        <input type="range" id="delayRange" min="3" max="10" value="5">
      </div>
      <button id="startBtn">Commencer la partie</button>
      <a href="chambre.html" class="btn-chambre-reception">Acc√©der √† la chambre de r√©ception</a>
    </div>

    <div id="game-ui" class="hidden">
      <div id="info"></div>
      <div id="timer"></div>
      <div id="scores"><span id="p1Score"></span><span id="p2Score"></span></div>
      <button id="restartBtn">Recommencer</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  
  <script>
    let scene, camera, renderer, raycaster, mouse;
    let boardGroup, holeObjects = [], seedObjects = [];
    let board, currentPlayer, scores, pNames, collectRule;
    let timerEnabled, timerDuration, timerId;
    let animating = false;
    
    const landing = document.getElementById('landing');
    const gameUI = document.getElementById('game-ui');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const info = document.getElementById('info');
    const timerEl = document.getElementById('timer');
    const p1ScoreEl = document.getElementById('p1Score');
    const p2ScoreEl = document.getElementById('p2Score');
    const delayRange = document.getElementById('delayRange');
    const delayValue = document.getElementById('delayValue');
    const collectRuleSel = document.getElementById('collectRule');
    
    const parcours = [[1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [0, 5], [0, 4], [0, 3], [0, 2], [0, 1], [0, 0]];

    // Sons am√©lior√©s
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    function playSound(freq, duration, type = 'sine', volume = 0.3) {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = freq;
      oscillator.type = type;
      
      gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + duration);
    }
    
    function playClickSound() { playSound(900, 0.08, 'sine', 0.25); }
    function playDropSound() { playSound(450, 0.12, 'triangle', 0.2); }
    function playCaptureSound() {
      playSound(650, 0.18, 'square', 0.25);
      setTimeout(() => playSound(750, 0.15, 'square', 0.2), 40);
      setTimeout(() => playSound(850, 0.12, 'sine', 0.18), 80);
    }
    function playWinSound() {
      playSound(523, 0.2, 'sine', 0.3);
      setTimeout(() => playSound(659, 0.2, 'sine', 0.3), 120);
      setTimeout(() => playSound(784, 0.35, 'sine', 0.35), 240);
    }

    delayRange.oninput = () => delayValue.textContent = delayRange.value;

    startBtn.onclick = () => {
      playClickSound();
      pNames = [document.getElementById('player1').value || 'Joueur 1', document.getElementById('player2').value || 'Joueur 2'];
      collectRule = collectRuleSel.value;
      timerEnabled = document.getElementById('enableTimer').checked;
      timerDuration = parseInt(delayRange.value);
      landing.classList.add('hidden');
      gameUI.classList.remove('hidden');
      initGame();
    };

    restartBtn.onclick = () => {
      playClickSound();
      initGame();
    };

    function initThree() {
      scene = new THREE.Scene();
      
      // Fond avec d√©grad√© am√©lior√©
      const canvas = document.createElement('canvas');
      canvas.width = 2048;
      canvas.height = 2048;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createLinearGradient(0, 0, 0, 2048);
      gradient.addColorStop(0, '#faf5ed');
      gradient.addColorStop(0.5, '#f5e6d3');
      gradient.addColorStop(1, '#e8d5b7');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 2048, 2048);
      
      const bgTexture = new THREE.CanvasTexture(canvas);
      scene.background = bgTexture;
      
      // Cam√©ra responsive
      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
      
      // Position adaptative de la cam√©ra
      if (aspect < 1.2) {
        camera.position.set(0, 16, 16);
        camera.fov = 60;
      } else {
        camera.position.set(0, 13, 14);
        camera.fov = 50;
      }
      camera.updateProjectionMatrix();
      camera.lookAt(0, 0, 0);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.physicallyCorrectLights = true;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      document.getElementById('canvas-container').appendChild(renderer.domElement);
      
      // Syst√®me d'√©clairage am√©lior√© pour voir les graines
      const ambientLight = new THREE.AmbientLight(0xfff8f0, 1.5);
      scene.add(ambientLight);
      
      const mainLight = new THREE.DirectionalLight(0xfff5e6, 2.0);
      mainLight.position.set(10, 25, 12);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 4096;
      mainLight.shadow.mapSize.height = 4096;
      mainLight.shadow.camera.left = -30;
      mainLight.shadow.camera.right = 30;
      mainLight.shadow.camera.top = 30;
      mainLight.shadow.camera.bottom = -30;
      mainLight.shadow.bias = -0.0003;
      mainLight.shadow.radius = 2;
      scene.add(mainLight);
      
      // Lumi√®res de remplissage pour √©liminer les ombres dans les trous
      const fillLight1 = new THREE.PointLight(0xfff8f0, 1.2, 35);
      fillLight1.position.set(-6, 5, -3);
      scene.add(fillLight1);
      
      const fillLight2 = new THREE.PointLight(0xfff8f0, 1.2, 35);
      fillLight2.position.set(6, 5, 3);
      scene.add(fillLight2);
      
      const fillLight3 = new THREE.PointLight(0xfff8f0, 0.9, 30);
      fillLight3.position.set(0, 5, -4);
      scene.add(fillLight3);
      
      const fillLight4 = new THREE.PointLight(0xfff8f0, 0.9, 30);
      fillLight4.position.set(0, 5, 4);
      scene.add(fillLight4);
      
      // Lumi√®re z√©nithale douce
      const topLight = new THREE.DirectionalLight(0xffffff, 1.0);
      topLight.position.set(0, 20, 0);
      scene.add(topLight);
      
      // H√©misph√®re pour √©clairage naturel
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0xe8d5b7, 0.8);
      scene.add(hemiLight);
      
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      window.addEventListener('resize', onWindowResize);
      renderer.domElement.addEventListener('click', onMouseClick);
      renderer.domElement.addEventListener('mousemove', onMouseMove);
      renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
      renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
      
      createBoard();
      animate3D();
    }

    function createWoodTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 2048;
      canvas.height = 2048;
      const ctx = canvas.getContext('2d');
      
      // Base bois riche
      const gradient = ctx.createLinearGradient(0, 0, 2048, 2048);
      gradient.addColorStop(0, '#d4a574');
      gradient.addColorStop(0.2, '#c9a876');
      gradient.addColorStop(0.5, '#b89968');
      gradient.addColorStop(0.8, '#a68958');
      gradient.addColorStop(1, '#8b7355');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 2048, 2048);
      
      // Veines du bois d√©taill√©es
      for (let i = 0; i < 150; i++) {
        ctx.strokeStyle = `rgba(${50 + Math.random() * 40}, ${35 + Math.random() * 25}, ${20 + Math.random() * 20}, ${0.12 + Math.random() * 0.28})`;
        ctx.lineWidth = 0.8 + Math.random() * 3.5;
        ctx.beginPath();
        const startX = Math.random() * 2048;
        ctx.moveTo(startX, 0);
        
        for (let j = 0; j < 8; j++) {
          const cpX = startX + (Math.random() - 0.5) * 700;
          const cpY = j * 300 + (Math.random() - 0.5) * 180;
          const endX = startX + (Math.random() - 0.5) * 900;
          const endY = (j + 1) * 300;
          ctx.quadraticCurveTo(cpX, cpY, endX, endY);
        }
        ctx.stroke();
      }
      
      // N≈ìuds du bois
      for (let i = 0; i < 40; i++) {
        const x = Math.random() * 2048;
        const y = Math.random() * 2048;
        const radius = 25 + Math.random() * 60;
        
        for (let ring = 5; ring > 0; ring--) {
          const grad = ctx.createRadialGradient(x, y, 0, x, y, radius * ring / 5);
          grad.addColorStop(0, `rgba(60, 40, 25, ${0.3 * ring / 5})`);
          grad.addColorStop(1, 'rgba(60, 40, 25, 0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(x, y, radius * ring / 5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Texture fine
      for (let i = 0; i < 8000; i++) {
        const x = Math.random() * 2048;
        const y = Math.random() * 2048;
        ctx.fillStyle = `rgba(${80 + Math.random() * 50}, ${50 + Math.random() * 30}, ${30 + Math.random() * 20}, ${0.05 + Math.random() * 0.15})`;
        ctx.fillRect(x, y, 1 + Math.random() * 2, 0.5 + Math.random());
      }
      
      const texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      return texture;
    }

    function createBoard() {
      boardGroup = new THREE.Group();
      
      const boardWidth = 19;
      const boardDepth = 9;
      const boardHeight = 1.5;
      const borderHeight = 1.3;
      const borderThickness = 1;
      
      const woodTexture = createWoodTexture();
      
      // Base du plateau avec texture
      const baseGeometry = new THREE.BoxGeometry(boardWidth, 0.6, boardDepth);
      const baseMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture,
        color: 0xa68958,
        roughness: 0.7,
        metalness: 0.08,
        envMapIntensity: 0.5
      });
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = -boardHeight / 2 - 0.3;
      base.receiveShadow = true;
      base.castShadow = true;
      boardGroup.add(base);
      
      // Surface int√©rieure ultra-claire pour maximum de visibilit√©
      const innerGeometry = new THREE.BoxGeometry(
        boardWidth - borderThickness * 2,
        0.5,
        boardDepth - borderThickness * 2
      );
      const innerMaterial = new THREE.MeshStandardMaterial({
        color: 0xf5e6d3, // Couleur papyrus tr√®s claire
        roughness: 0.5,
        metalness: 0.05,
        emissive: 0xf5e6d3,
        emissiveIntensity: 0.15
      });
      const inner = new THREE.Mesh(innerGeometry, innerMaterial);
      inner.position.y = -boardHeight / 2 + 0.5;
      inner.receiveShadow = true;
      boardGroup.add(inner);
      
      // Bordures avec texture bois
      const borderMaterial = new THREE.MeshStandardMaterial({
        map: woodTexture,
        color: 0x8b7355,
        roughness: 0.75,
        metalness: 0.08
      });
      
      // Bordure haute
      const topBorder = new THREE.Mesh(
        new THREE.BoxGeometry(boardWidth, borderHeight, borderThickness),
        borderMaterial
      );
      topBorder.position.set(0, -boardHeight / 2 + borderHeight / 2, -boardDepth / 2 + borderThickness / 2);
      topBorder.castShadow = true;
      topBorder.receiveShadow = true;
      boardGroup.add(topBorder);
      
      // Bordure basse
      const bottomBorder = new THREE.Mesh(
        new THREE.BoxGeometry(boardWidth, borderHeight, borderThickness),
        borderMaterial
      );
      bottomBorder.position.set(0, -boardHeight / 2 + borderHeight / 2, boardDepth / 2 - borderThickness / 2);
      bottomBorder.castShadow = true;
      bottomBorder.receiveShadow = true;
      boardGroup.add(bottomBorder);
      
      // Bordure gauche
      const leftBorder = new THREE.Mesh(
        new THREE.BoxGeometry(borderThickness, borderHeight, boardDepth),
        borderMaterial
      );
      leftBorder.position.set(-boardWidth / 2 + borderThickness / 2, -boardHeight / 2 + borderHeight / 2, 0);
      leftBorder.castShadow = true;
      leftBorder.receiveShadow = true;
      boardGroup.add(leftBorder);
      
      // Bordure droite
      const rightBorder = new THREE.Mesh(
        new THREE.BoxGeometry(borderThickness, borderHeight, boardDepth),
        borderMaterial
      );
      rightBorder.position.set(boardWidth / 2 - borderThickness / 2, -boardHeight / 2 + borderHeight / 2, 0);
      rightBorder.castShadow = true;
      rightBorder.receiveShadow = true;
      boardGroup.add(rightBorder);
      
      // Charni√®res m√©talliques r√©alistes
      createHinge(-7, 0);
      createHinge(7, 0);
      
      // Trous peu profonds pour visibilit√© maximale
      holeObjects = [];
      const holeRadius = 1.25;
      const holeDepth = 0.4; // Tr√®s peu profond
      const spacingX = 2.9;
      const spacingZ = 3.5;
      
      for (let r = 0; r < 2; r++) {
        for (let c = 0; c < 6; c++) {
          const x = -7.25 + c * spacingX;
          const z = r === 0 ? -spacingZ / 2 : spacingZ / 2;
          
          const holeGroup = createHole(x, z, holeRadius, holeDepth, r, c);
          boardGroup.add(holeGroup);
          holeObjects.push(holeGroup);
        }
      }
      
      scene.add(boardGroup);
    }

    function createHinge(x, z) {
      const hingeGeometry = new THREE.BoxGeometry(0.7, 0.3, 1.3);
      const metalMaterial = new THREE.MeshStandardMaterial({
        color: 0x404040,
        metalness: 0.98,
        roughness: 0.12,
        envMapIntensity: 1.5
      });
      const hinge = new THREE.Mesh(hingeGeometry, metalMaterial);
      hinge.position.set(x, 0.6, z);
      hinge.castShadow = true;
      boardGroup.add(hinge);
      
      // Axe brillant
      const axis = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 1.4, 20),
        metalMaterial
      );
      axis.position.set(x, 0.7, z);
      axis.rotation.x = Math.PI / 2;
      boardGroup.add(axis);
      
      // Vis d√©taill√©es
      const screwMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1a1a1a, 
        metalness: 0.95, 
        roughness: 0.15 
      });
      
      const positions = [[x - 0.25, z - 0.5], [x + 0.25, z - 0.5], [x - 0.25, z + 0.5], [x + 0.25, z + 0.5]];
      positions.forEach(([px, pz]) => {
        const screw = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 0.12, 16),
          screwMaterial
        );
        screw.position.set(px, 0.75, pz);
        screw.rotation.x = Math.PI / 2;
        boardGroup.add(screw);
        
        // Croix sur la vis
        const slotGeometry = new THREE.BoxGeometry(0.15, 0.02, 0.02);
        const slot1 = new THREE.Mesh(slotGeometry, screwMaterial);
        slot1.position.set(px, 0.81, pz);
        boardGroup.add(slot1);
        
        const slot2 = new THREE.Mesh(slotGeometry, screwMaterial);
        slot2.position.set(px, 0.81, pz);
        slot2.rotation.y = Math.PI / 2;
        boardGroup.add(slot2);
      });
    }

    function createHole(x, z, radius, depth, row, col) {
      const holeGroup = new THREE.Group();
      holeGroup.position.set(x, 0, z);
      holeGroup.userData = { row, col, isHole: true };
      
      // Parois du trou tr√®s claires
      const holeGeometry = new THREE.CylinderGeometry(radius, radius * 0.96, depth, 56);
      const holeMaterial = new THREE.MeshStandardMaterial({
        color: 0xd4c4a8,
        roughness: 0.75,
        metalness: 0.02,
        emissive: 0xd4c4a8,
        emissiveIntensity: 0.1
      });
      const hole = new THREE.Mesh(holeGeometry, holeMaterial);
      hole.position.y = -depth / 2 + 0.6;
      hole.receiveShadow = true;
      holeGroup.add(hole);
      
      // Fond du trou ultra-clair
      const bottomGeometry = new THREE.CircleGeometry(radius * 0.96, 56);
      const bottomMaterial = new THREE.MeshStandardMaterial({
        color: 0xe8dcc8,
        roughness: 0.6,
        metalness: 0.05,
        emissive: 0xe8dcc8,
        emissiveIntensity: 0.2
      });
      const bottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
      bottom.rotation.x = -Math.PI / 2;
      bottom.position.y = -depth + 0.6;
      bottom.receiveShadow = true;
      holeGroup.add(bottom);
      
      // Bordure arrondie √©l√©gante
      const ringGeometry = new THREE.TorusGeometry(radius, 0.18, 24, 56);
      const ringMaterial = new THREE.MeshStandardMaterial({
        color: 0x8b7355,
        roughness: 0.65,
        metalness: 0.12
      });
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.rotation.x = Math.PI / 2;
      ring.position.y = 0.6;
      ring.castShadow = true;
      ring.receiveShadow = true;
      holeGroup.add(ring);
      
      return holeGroup;
    }

    function createSeed(x, y, z) {
      // Graine ultra-visible avec √©clat naturel
      const seedGeometry = new THREE.SphereGeometry(0.3, 28, 28);
      seedGeometry.scale(1, 0.88, 1.12);
      
      const seedColors = [
        0xfffaf5,  // Blanc neige
        0xfff8f0,  // Blanc cass√©
        0xfff0e0,  // Ivoire clair
        0xffe8d0,  // Cr√®me l√©g√®re
        0xffddb8,  // Beige tr√®s p√¢le
        0xf5e6d2   // Beige clair
      ];
      
      const color = seedColors[Math.floor(Math.random() * seedColors.length)];
      
      const seedMaterial = new THREE.MeshStandardMaterial({
        color: color,
        roughness: 0.45,
        metalness: 0.15,
        emissive: color,
        emissiveIntensity: 0.25,
        clearcoat: 0.3,
        clearcoatRoughness: 0.4
      });
      
      const seed = new THREE.Mesh(seedGeometry, seedMaterial);
      seed.position.set(x, y, z);
      seed.castShadow = true;
      seed.receiveShadow = true;
      
      seed.rotation.x = Math.random() * Math.PI * 2;
      seed.rotation.y = Math.random() * Math.PI * 2;
      seed.rotation.z = Math.random() * Math.PI * 2;
      
      return seed;
    }

    function getHolePosition(row, col) {
      const x = -7.25 + col * 2.9;
      const z = row === 0 ? -1.75 : 1.75;
      return { x, z };
    }

    function positionSeedsInHole(row, col, count) {
      const seeds = [];
      const pos = getHolePosition(row, col);
      
      if (count === 0) return seeds;
      
      for (let i = 0; i < count; i++) {
        let sx, sz, sy;
        
        if (count === 1) {
          sx = pos.x;
          sz = pos.z;
          sy = 0.35; // Bien visible !
        } else if (count <= 4) {
          const angle = (i / count) * Math.PI * 2 + Math.PI / 4;
          const radius = 0.52;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = 0.35;
        } else if (count <= 8) {
          const layer = Math.floor(i / 4);
          const posInLayer = i % 4;
          const angle = (posInLayer / 4) * Math.PI * 2 + Math.PI / 4;
          const radius = layer === 0 ? 0.58 : 0.32;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = 0.35 + layer * 0.38;
        } else {
          const layer = Math.floor(i / 6);
          const posInLayer = i % 6;
          const angle = (posInLayer / 6) * Math.PI * 2;
          const radius = 0.42 + (layer % 2) * 0.28;
          sx = pos.x + Math.cos(angle) * radius;
          sz = pos.z + Math.sin(angle) * radius;
          sy = 0.35 + layer * 0.35;
        }
        
        seeds.push({ x: sx, y: sy, z: sz });
      }
      
      return seeds;
    }

    function updateSeeds() {
      seedObjects.forEach(seed => boardGroup.remove(seed));
      seedObjects = [];
      
      for (let r = 0; r < 2; r++) {
        for (let c = 0; c < 6; c++) {
          const count = board[r][c];
          const positions = positionSeedsInHole(r, c, count);
          
          positions.forEach(pos => {
            const seed = createSeed(pos.x, pos.y, pos.z);
            boardGroup.add(seed);
            seedObjects.push(seed);
          });
        }
      }
    }

    function animate3D() {
      requestAnimationFrame(animate3D);
      
      // Animation subtile des graines
      seedObjects.forEach((seed, i) => {
        seed.rotation.y += 0.003 * Math.sin(i * 0.25);
        seed.position.y += Math.sin(Date.now() * 0.001 + i * 0.5) * 0.001;
      });
      
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;
      camera.aspect = aspect;
      
      // Ajustement de la cam√©ra selon l'aspect ratio
      if (aspect < 1.2) {
        camera.fov = 60;
        camera.position.set(0, 16, 16);
      } else if (aspect < 1.5) {
        camera.fov = 55;
        camera.position.set(0, 14, 15);
      } else {
        camera.fov = 50;
        camera.position.set(0, 13, 14);
      }
      
      camera.updateProjectionMatrix();
      camera.lookAt(0, 0, 0);
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    let touchStartPos = null;

    function onTouchStart(event) {
      event.preventDefault();
      if (animating) return;
      
      const touch = event.touches[0];
      touchStartPos = { x: touch.clientX, y: touch.clientY };
      
      mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
    }

    function onTouchEnd(event) {
      event.preventDefault();
      if (animating || !touchStartPos) return;
      
      const touch = event.changedTouches[0];
      const dx = touch.clientX - touchStartPos.x;
      const dy = touch.clientY - touchStartPos.y;
      
      // V√©rifier que c'est un tap et pas un swipe
      if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(holeObjects, true);
        
        if (intersects.length > 0) {
          let hole = intersects[0].object;
          while (hole.parent && !hole.userData.isHole) {
            hole = hole.parent;
          }
          
          if (hole.userData.isHole) {
            const r = hole.userData.row;
            const c = hole.userData.col;
            
            if ((currentPlayer === 1 && r === 1) || (currentPlayer === 2 && r === 0)) {
              if (board[r][c] > 0) {
                playClickSound();
                play(r, c);
              }
            }
          }
        }
      }
      
      touchStartPos = null;
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      holeObjects.forEach(hole => {
        hole.children.forEach(child => {
          if (child.material && child.material.emissive) {
            child.material.emissive.setHex(child.material.color.getHex());
            child.material.emissiveIntensity = child === hole.children[1] ? 0.2 : 0.1;
          }
        });
      });
      
      if (intersects.length > 0 && !animating) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          const r = hole.userData.row;
          const c = hole.userData.col;
          
          if ((currentPlayer === 1 && r === 1) || (currentPlayer === 2 && r === 0)) {
            if (board[r][c] > 0) {
              hole.children.forEach(child => {
                if (child.material && child.material.emissive) {
                  child.material.emissive.setHex(0xffa500);
                  child.material.emissiveIntensity = 0.6;
                }
              });
              renderer.domElement.style.cursor = 'pointer';
              return;
            }
          }
        }
      }
      renderer.domElement.style.cursor = 'default';
    }

    function onMouseClick(event) {
      if (animating) return;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(holeObjects, true);
      
      if (intersects.length > 0) {
        let hole = intersects[0].object;
        while (hole.parent && !hole.userData.isHole) {
          hole = hole.parent;
        }
        
        if (hole.userData.isHole) {
          const r = hole.userData.row;
          const c = hole.userData.col;
          
          if ((currentPlayer === 1 && r === 1) || (currentPlayer === 2 && r === 0)) {
            if (board[r][c] > 0) {
              playClickSound();
              play(r, c);
            }
          }
        }
      }
    }

    function initGame() {
      board = Array.from({ length: 2 }, () => Array(6).fill(4));
      scores = [0, 0];
      currentPlayer = 1;
      animating = false;
      updateDisplay();
      updateSeeds();
    }

    function startTimer() {
      clearTimer();
      if (!timerEnabled) return;
      let rem = timerDuration;
      timerEl.textContent = `Temps: ${rem}s`;
      timerId = setInterval(() => {
        rem--;
        timerEl.textContent = `Temps: ${rem}s`;
        if (rem < 0) {
          clearTimer();
          const loser = currentPlayer;
          const winner = loser === 1 ? 2 : 1;
          const msg = `Temps √©coul√© ! ${pNames[loser - 1]} n'a pas jou√© √† temps.\n${pNames[winner - 1]} remporte la partie.`;
          handleWinner(winner, msg, false);
        }
      }, 1000);
    }

    function clearTimer() {
      clearInterval(timerId);
      timerEl.textContent = '';
    }

    function updateDisplay() {
      p1ScoreEl.textContent = `${pNames[0]}: ${scores[0]}`;
      p2ScoreEl.textContent = `${pNames[1]}: ${scores[1]}`;
      info.textContent = `Tour de ${pNames[currentPlayer - 1]}`;
      startTimer();
    }

    async function animateSeedMovement(seed, startPos, endPos) {
      const duration = 650;
      const startTime = Date.now();
      
      return new Promise(resolve => {
        function animate() {
          const elapsed = Date.now() - startTime;
          const t = Math.min(elapsed / duration, 1);
          
          const easeT = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
          
          const height = 3.8;
          seed.position.x = startPos.x + (endPos.x - startPos.x) * easeT;
          seed.position.z = startPos.z + (endPos.z - startPos.z) * easeT;
          seed.position.y = startPos.y + Math.sin(easeT * Math.PI) * height;
          
          seed.rotation.x += 0.2;
          seed.rotation.y += 0.17;
          seed.rotation.z += 0.13;
          
          if (t < 1) {
            requestAnimationFrame(animate);
          } else {
            seed.position.set(endPos.x, endPos.y, endPos.z);
            resolve();
          }
        }
        animate();
      });
    }

    async function play(r0, c0) {
      if (animating) return;
      animating = true;
      clearTimer();
      
      let seedCount = board[r0][c0];
      if (!seedCount) {
        animating = false;
        return;
      }
      
      board[r0][c0] = 0;
      let idx = parcours.findIndex(p => p[0] === r0 && p[1] === c0);
      
      const startPositions = positionSeedsInHole(r0, c0, seedCount);
      const movingSeeds = [];
      
      for (let i = 0; i < seedCount; i++) {
        const pos = startPositions[i];
        const seed = createSeed(pos.x, pos.y, pos.z);
        boardGroup.add(seed);
        movingSeeds.push(seed);
      }
      
      updateSeeds();
      await new Promise(resolve => setTimeout(resolve, 120));
      
      for (let i = 0; i < movingSeeds.length; i++) {
        const seed = movingSeeds[i];
        idx = (idx + 1) % 12;
        let [r, c] = parcours[idx];
        
        if (r === r0 && c === c0) {
          idx = (idx + 1) % 12;
          [r, c] = parcours[idx];
        }
        
        board[r][c]++;
        
        const startPos = getHolePosition(r0, c0);
        const endPositions = positionSeedsInHole(r, c, board[r][c]);
        const endPos = endPositions[endPositions.length - 1];
        
        playDropSound();
        await animateSeedMovement(seed, startPos, endPos);
        
        boardGroup.remove(seed);
        updateSeeds();
        
        await new Promise(resolve => setTimeout(resolve, 140));
      }
      
      let cap = 0, count = 0, j = idx;
      while (count < 5) {
        let [r, c] = parcours[j];
        if ((currentPlayer === 1 && r === 0) || (currentPlayer === 2 && r === 1)) {
          let v = board[r][c];
          if (v === 2 || v === 3) {
            cap += v;
            playCaptureSound();
            
            const capturePositions = positionSeedsInHole(r, c, v);
            const capturingSeeds = [];
            
            for (let pos of capturePositions) {
              const seed = createSeed(pos.x, pos.y, pos.z);
              boardGroup.add(seed);
              capturingSeeds.push(seed);
            }
            
            board[r][c] = 0;
            updateSeeds();
            
            const captureStart = Date.now();
            const captureDuration = 480;
            
            await new Promise(resolve => {
              function animateCapture() {
                const elapsed = Date.now() - captureStart;
                const progress = Math.min(elapsed / captureDuration, 1);
                
                capturingSeeds.forEach((seed, i) => {
                  const scale = 1 - progress;
                  seed.scale.set(scale, scale, scale);
                  seed.position.y += 0.12;
                  seed.rotation.y += 0.35;
                  seed.rotation.x += 0.25;
                });
                
                if (progress < 1) {
                  requestAnimationFrame(animateCapture);
                } else {
                  capturingSeeds.forEach(seed => boardGroup.remove(seed));
                  resolve();
                }
              }
              animateCapture();
            });
            
            await new Promise(resolve => setTimeout(resolve, 180));
            
            count++;
            j = (j - 1 + 12) % 12;
            continue;
          }
        }
        break;
      }
      
      scores[currentPlayer - 1] += cap;
      
      const next = currentPlayer === 1 ? 2 : 1;
      const flat = board.flat();
      
      if (flat.every(v => v === 0) || board[next === 1 ? 1 : 0].every(v => v === 0)) {
        const remaining = flat.reduce((a, b) => a + b, 0);
        board = Array.from({ length: 2 }, () => Array(6).fill(0));
        let collector = collectRule === 'current' ? currentPlayer : (currentPlayer === 1 ? 2 : 1);
        const before = scores[collector - 1];
        scores[collector - 1] += remaining;
        const total = scores[collector - 1];
        
        let message = `${pNames[collector - 1]} ramasse ${remaining} graines.\nScore: ${before}+${remaining}=${total}`;
        if (total > 24) message += `\nüéâ ${pNames[collector - 1]} gagne !`;
        else if (total === 24) message += `\n√âGALIT√â 24-24, nouvelle partie !`;
        else message += `\nMoins de 25: ${pNames[(collector === currentPlayer ? next : currentPlayer) - 1]} gagne !`;
        
        handleWinner(collector, message, total === 24);
        animating = false;
        return;
      }
      
      if (scores[currentPlayer - 1] >= 25) {
        handleWinner(currentPlayer, `üéâ ${pNames[currentPlayer - 1]} atteint 25 graines !`, false);
        animating = false;
        return;
      }
      
      currentPlayer = next;
      updateDisplay();
      animating = false;
    }

    function handleWinner(idx, message, isTie = false) {
      clearTimer();
      playWinSound();
      confetti({ 
        particleCount: 500, 
        spread: 140, 
        origin: { y: 0.6 },
        colors: ['#FFD700', '#FFA500', '#FF6347', '#FF69B4', '#00CED1']
      });
      
      let s1 = scores[0], s2 = scores[1];
      let final = message + `\nScore final: ${s1}-${s2}`;
      
      if (isTie) {
        final += `\nRecommence dans 2s.`;
        timerDuration = Math.max(3, timerDuration - 1);
        info.textContent = final;
        setTimeout(initGame, 2000);
      } else {
        info.textContent = final;
      }
    }

    initThree();
  </script>
</body>
</html>
