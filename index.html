<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Three.js — Avatar présente panneau d'inscription/connexion</title>
  <style>
    html,body{height:100%;margin:0;background:#081018;overflow:hidden;font-family:Inter,Arial,Helvetica,sans-serif}
    #overlay{position:absolute;left:12px;top:12px;z-index:20;color:#cfe;font-family:monospace;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px}
    #hint{position:absolute;left:12px;bottom:12px;z-index:20;color:#9aa;background:rgba(0,0,0,0.25);padding:6px 8px;border-radius:6px}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="overlay">Demo : avatar → panneau 3D (clique sur les boutons)</div>
  <div id="hint">Contrôles : drag → orbiter, molette → zoom</div>

  <!-- Import local three as module (three.min.js is a module / ES build you saved) -->
  <script type="module">
  import * as THREE from './three.min.js';

  // ---- Helpers and DOM ----
  const overlay = document.getElementById('overlay');

  function log(msg){
    overlay.textContent = 'Demo : ' + msg;
    console.log(msg);
  }

  // ---- Scene / Camera / Renderer ----
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x071021);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.05, 100);
  camera.position.set(0, 1.6, 5);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.body.appendChild(renderer.domElement);

  // OrbitControls (simple local fallback)
  let orbitEnabled = true;
  // small inline orbit controls
  let isDown=false, sx=0, sy=0, yaw=0, pitch=-0.15;
  renderer.domElement.addEventListener('pointerdown', e=>{ isDown=true; sx=e.clientX; sy=e.clientY; renderer.domElement.setPointerCapture(e.pointerId); });
  window.addEventListener('pointerup', ()=>{ isDown=false; });
  window.addEventListener('pointermove', e=>{ if(!isDown) return; const dx=(e.clientX-sx)*0.005; const dy=(e.clientY-sy)*0.005; yaw += dx; pitch = Math.max(-1.2, Math.min(1.2, pitch+dy)); sx=e.clientX; sy=e.clientY; });
  window.addEventListener('wheel', e=>{ camera.position.z += e.deltaY*0.0025; camera.position.z = Math.max(1.6, Math.min(12, camera.position.z)); });

  // ---- Lights ----
  const dir = new THREE.DirectionalLight(0xffffff, 1.2);
  dir.position.set(5, 8, 3);
  dir.castShadow = true;
  dir.shadow.mapSize.set(1024,1024);
  scene.add(dir);
  scene.add(new THREE.AmbientLight(0x304050, 0.7));

  // ---- Ground ----
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(40,40),
    new THREE.MeshStandardMaterial({ color:0x06131a, roughness:0.95, metalness:0.0 })
  );
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -0.9;
  ground.receiveShadow = true;
  scene.add(ground);

  // subtle grid
  const grid = new THREE.GridHelper(30, 60, 0x0a2b33, 0x031012);
  grid.position.y = -0.899;
  scene.add(grid);

  // ---- Avatar (simple stylized humanoid) ----
  function buildAvatar(){
    const group = new THREE.Group();

    // torso
    const mat = new THREE.MeshStandardMaterial({ color: 0x9fbde6, roughness:0.5, metalness:0.05 });
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.9,0.35), mat);
    torso.position.y = 0.4;
    torso.castShadow = true;
    group.add(torso);

    // head
    const headMat = new THREE.MeshStandardMaterial({ color:0xffddaa, roughness:0.6 });
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.26, 24, 24), headMat);
    head.position.set(0, 1.05, 0);
    head.castShadow = true;
    group.add(head);

    // left arm
    const armGeo = new THREE.CylinderGeometry(0.08,0.08,0.7,12);
    const leftArm = new THREE.Mesh(armGeo, mat);
    leftArm.position.set(-0.5, 0.6, 0);
    leftArm.rotation.z = Math.PI/6;
    leftArm.castShadow = true;
    group.add(leftArm);

    // right arm
    const rightArm = new THREE.Mesh(armGeo, mat);
    rightArm.position.set(0.5, 0.6, 0);
    rightArm.rotation.z = -Math.PI/6;
    rightArm.castShadow = true;
    group.add(rightArm);

    // legs
    const legGeo = new THREE.CylinderGeometry(0.12,0.12,0.9,12);
    const lLeg = new THREE.Mesh(legGeo, mat);
    lLeg.position.set(-0.18, -0.5, 0);
    lLeg.castShadow = true;
    group.add(lLeg);
    const rLeg = new THREE.Mesh(legGeo, mat);
    rLeg.position.set(0.18, -0.5, 0);
    rLeg.castShadow = true;
    group.add(rLeg);

    // small eyes
    const eyeMat = new THREE.MeshStandardMaterial({ color:0x111111, roughness:0.8 });
    const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.03,8,8), eyeMat);
    eyeL.position.set(-0.08,1.07,0.24);
    group.add(eyeL);
    const eyeR = eyeL.clone(); eyeR.position.x = 0.08; group.add(eyeR);

    // make parts accessible for animation
    group.userData = { torso, head, leftArm, rightArm, lLeg, rLeg };
    return group;
  }

  const avatar = buildAvatar();
  avatar.position.set(-6, -0.9, 0); // start far left
  avatar.scale.setScalar(1.0);
  scene.add(avatar);

  // ---- Panneau 3D (UI) ----
  // We'll create a canvas texture that looks like a sign-up/login panel and map it on a plane
  const panelWidth = 1.8, panelHeight = 1.2;
  const uiCanvas = document.createElement('canvas');
  uiCanvas.width = 1024;
  uiCanvas.height = 768;
  const uiCtx = uiCanvas.getContext('2d');

  function drawPanel(state='login'){
    // background
    uiCtx.clearRect(0,0,uiCanvas.width,uiCanvas.height);
    uiCtx.fillStyle = '#0b1a22';
    uiCtx.fillRect(0,0,uiCanvas.width,uiCanvas.height);

    // header
    uiCtx.fillStyle = '#8ad6ff';
    uiCtx.font = '48px sans-serif';
    uiCtx.fillText(state === 'login' ? 'Se connecter' : 'S\'inscrire', 48, 80);

    // form boxes (visual only)
    uiCtx.strokeStyle = '#2b6170';
    uiCtx.lineWidth = 4;
    const bx = 48, by = 130, bw = uiCanvas.width - 96, bh = 92;
    uiCtx.strokeRect(bx, by, bw, bh);
    uiCtx.font = '28px sans-serif';
    uiCtx.fillStyle = '#cdeefc';
    uiCtx.fillText('Adresse e-mail', bx+12, by+42);

    uiCtx.strokeRect(bx, by+110, bw, bh);
    uiCtx.fillText('Mot de passe', bx+12, by+110+42);

    // big button
    uiCtx.fillStyle = '#16a085';
    uiCtx.fillRect(bx, by+250, bw, 86);
    uiCtx.fillStyle = '#ffffff';
    uiCtx.font = '36px sans-serif';
    uiCtx.fillText(state === 'login' ? 'Se connecter' : 'S\'inscrire', bx + 30, by+250+56);

    // switch link
    uiCtx.fillStyle = '#9be6ff';
    uiCtx.font = '22px sans-serif';
    uiCtx.fillText(state === 'login' ? 'Créer un compte' : 'J\'ai déjà un compte', bx+12, by+360);

    // small decorative info
    uiCtx.font = '18px sans-serif';
    uiCtx.fillStyle = '#8fb7c0';
    uiCtx.fillText('Presented by AvatarUI', bx+12, uiCanvas.height - 32);
  }

  // initial state
  let panelState = 'login';
  drawPanel(panelState);
  const uiTexture = new THREE.CanvasTexture(uiCanvas);
  uiTexture.minFilter = THREE.LinearFilter;
  uiTexture.wrapS = uiTexture.wrapT = THREE.ClampToEdgeWrapping;

  const panelMat = new THREE.MeshBasicMaterial({ map: uiTexture, side: THREE.DoubleSide });
  const panel = new THREE.Mesh(new THREE.PlaneGeometry(panelWidth, panelHeight), panelMat);
  panel.position.set(0, 0.2, 0);
  panel.rotation.y = -0.15;
  panel.castShadow = true;
  scene.add(panel);

  // small stand for panel
  const stand = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.8, 0.12), new THREE.MeshStandardMaterial({ color:0x233b46 }));
  stand.position.set(0, -0.3, -0.08);
  scene.add(stand);

  // ---- Interaction: raycast to detect clicks on panel buttons ----
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();

  function onPointerDown(e){
    // compute pointer normalized coordinates
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);
    const hits = raycaster.intersectObject(panel);
    if(hits.length){
      // compute uv coordinate on plane
      const uv = hits[0].uv; // vector2
      // map uv to canvas pixel
      const px = Math.floor(uv.x * uiCanvas.width);
      const py = Math.floor((1 - uv.y) * uiCanvas.height);
      handleUIPress(px, py);
    }
  }
  renderer.domElement.addEventListener('pointerdown', onPointerDown);

  function handleUIPress(px, py){
    // coordinates we used earlier to draw:
    const bx = 48, by = 130, bw = uiCanvas.width - 96, bh = 92;
    // login/signup button area
    const btnY = by + 250, btnH = 86;
    if(px >= bx && px <= bx + bw && py >= btnY && py <= btnY + btnH){
      // main action pressed
      if(panelState === 'login'){
        log('Action: tentative de connexion (simulée)');
        flashPanel('Connexion…');
      } else {
        log('Action: tentative d\'inscription (simulée)');
        flashPanel('Inscription…');
      }
      return;
    }
    // switch link
    const linkY = by + 360 - 20, linkH = 40;
    if(px >= bx && px <= bx + 400 && py >= linkY && py <= linkY + linkH){
      panelState = panelState === 'login' ? 'signup' : 'login';
      drawPanel(panelState);
      uiTexture.needsUpdate = true;
      log('Changement d\'état UI → ' + panelState);
      return;
    }
    // clicked on fields — just show feedback
    if(px >= bx && px <= bx+bw && py >= by && py <= by+bh){
      log('Cliqué sur le champ e-mail (simulé)');
      flashPanel('Saisie e-mail');
      return;
    }
    if(px >= bx && px <= bx+bw && py >= by+110 && py <= by+110+bh){
      log('Cliqué sur le champ mot de passe (simulé)');
      flashPanel('Saisie mot de passe');
      return;
    }
    // else
    log('Clique hors zones interactives (px:'+px+', py:'+py+')');
  }

  // small visual flash on panel (draw temporary overlay)
  function flashPanel(text){
    const save = uiCtx.getImageData(0,0,uiCanvas.width,uiCanvas.height);
    uiCtx.fillStyle = 'rgba(255,255,255,0.06)';
    uiCtx.fillRect(0,0,uiCanvas.width,uiCanvas.height);
    uiCtx.fillStyle = '#fff';
    uiCtx.font = '48px sans-serif';
    uiCtx.fillText(text, 60, uiCanvas.height/2);
    uiTexture.needsUpdate = true;
    setTimeout(()=>{ uiCtx.putImageData(save,0,0); uiTexture.needsUpdate = true; }, 700);
  }

  // ---- Avatar animation state machine ----
  let avatarState = 'walk_in'; // walk_in -> present -> idle -> done
  let stateTimer = 0;

  function updateAvatar(dt){
    stateTimer += dt;
    if(avatarState === 'walk_in'){
      // move from x=-6 to x=-1.6
      const start = -6, end = -1.6, duration = 3.0;
      const t = Math.min(1, stateTimer / duration);
      avatar.position.x = start + (end - start) * easeOutCubic(t);
      // simple leg animation (swing)
      const speed = 6;
      avatar.userData.lLeg.rotation.x = Math.sin(stateTimer*speed) * 0.9;
      avatar.userData.rLeg.rotation.x = Math.sin(stateTimer*speed + Math.PI) * 0.9;
      avatar.userData.leftArm.rotation.x = Math.sin(stateTimer*speed + Math.PI/2)*0.6;
      avatar.userData.rightArm.rotation.x = Math.sin(stateTimer*speed)*0.6;
      if(t >= 1){
        avatarState = 'present';
        stateTimer = 0;
      }
    } else if(avatarState === 'present'){
      // rotate to face panel and raise right arm
      avatar.rotation.y = THREE.MathUtils.lerp(avatar.rotation.y, 0.35, Math.min(1, stateTimer*1.6));
      // raise right arm upward
      avatar.userData.rightArm.rotation.x = THREE.MathUtils.lerp(avatar.userData.rightArm.rotation.x, -1.0, Math.min(1, stateTimer*1.8));
      if(stateTimer > 1.2){
        avatarState = 'idle';
        stateTimer = 0;
      }
    } else if(avatarState === 'idle'){
      // small breathing/idle movement
      const bob = Math.sin(perfTime*1.2)*0.005;
      avatar.position.y = -0.9 + bob;
      avatar.userData.head.rotation.y = Math.sin(perfTime*0.45)*0.06;
      // keep small arm wave occasionally
      if(stateTimer > 2.5){
        avatar.userData.rightArm.rotation.x = -0.9 + Math.sin(stateTimer*3)*0.25;
      }
    }
  }

  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

  // ---- Animation loop ----
  let prevTime = performance.now() / 1000;
  let perfTime = 0;
  function animate(){
    const now = performance.now() / 1000;
    const dt = Math.min(0.05, now - prevTime);
    prevTime = now;
    perfTime += dt;

    // update camera orbit from yaw/pitch
    const radius = camera.position.z;
    const camX = Math.cos(yaw) * radius;
    const camZ = Math.sin(yaw) * radius;
    const camY = Math.sin(pitch) * radius + 1.1;
    camera.position.set(camX, camY, camZ);
    camera.lookAt(0, 0.2, 0);

    updateAvatar(dt);

    // refresh panel texture if needed (we update only on actions, but ensure correct mapping)
    // uiTexture.needsUpdate = true; // update only when drawPanel/flashPanel called

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // initial camera rotation values
  yaw = -Math.PI/2 + 0.6;
  pitch = -0.15;

  // start
  log('Initialisation terminée — avatar arrive');
  animate();

  // resize handler
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  </script>
</body>
</html>
